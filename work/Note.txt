我的google账号  fujiyong2000@gmail.com  yaxin


WIFI 13622228504
ftp \\192.168.1.182     user:user
git fu_ji_yong fujy6789
bug fu_ji_yong pass@2019

google youtube  fujiyong2000@gmail.com  sr


测试机	121.9.227.91	22124	root	pass@2019
数据库	192.168.1.102	5432	postgres	pass@2018
ipfs1	192.168.1.106	22	root	13622228504
ipfs2	192.168.1.178	22	root	13622228504
ipfs3	192.168.1.120	22	root	13622228504
以太坊1	120.79.97.248	22	root	Svdsdev2019*$()
以太坊2	120.78.173.134	22	root	Svdsdev2019*$()
以太坊3	39.108.104.133	22	root	Svdsdev2019*$()
测试机  192.168.1.128  root/orangepi  orangepi  

git clone http://fu_ji_yong:fujy6789@git.isecsp.com/frank/ocelot-api-gateway.git

zsh操作指南
http://www.skywind.me/blog/archives/2060



alias | grep -E "b\."
echo $DIFOSS_ENV_BASE/.privacy/__init__.sh
b.privacy


https://www.npmjs.com/package/windows-build-tools  npm安装windows编译工具

linux命令  column -t
            for i in 0 1 2 3 4 5 6 7 8 9; do iostat | column -t; sleep 1; done
            for i in {0..9} ; do iostat 1 1 | column -t; sleep 1; done
            vmstat 1 10 | while read line
            do
                echo "$line" | column -t
            done

            在终端直接执行在a.sh中定义的函数say():  chmod +x a.sh && source a.sh && say
            last     最后登录信息,每个用户可以多行
            lastlog  最后各个用户的登录信息,每个登录用户一行

软件 web        hbuilder 
     数据库客   dbeave  pgadmin
     cmder     设置分屏
     markdonw  typora
     截图       snipaste

     nodejs进程管理  pm2  process manager

     mac      dash参考文档


https://www.cnblogs.com/the-tops/p/7600985.html
知识点
    git fetch --all  //所有分支
    确定自己所在分支 git pull origin master && git log -p -1   //-p 以patch方式  
    git shortlog
    git log 
            --stat 
            -p


             符号位     指数位     尾数位
    float    1          8         23
    double   1          11        52

    mkdir -pv a/b/c
    realpath $file
    ssh user@hostname/ip

    在命令行上参数上有些--符号,表示--跟在--之后的就不再是不确定参数,即参数不再是变量,而是确定量
    --             indicates the unambiguous end of options    #man awk 

    vi  set cursorline
        set cursorcolumn   https://github.com/nathanaelkane/vim-indent-guides





mist 以太坊节点/钱包
metamask chrome插件方式的以太坊节点、钱包， 可以连接到本地或实际的
truffle  以太坊开发框架，内置了只能合约的编译 链接 部署
remix   智能合约开发环境
whisper 集成进以太坊的非实时消息系统

ganache 在公链上测试部署dapp或只能合约需要消耗gas， 使用ganache可以创建本地区块链


npm install -g truffle  && truffle --version 


git clone http://fu_ji_yong:fujy6789@git.isecsp.com/frank/ocelot-api-gateway.git



npm
    npm init
    npm adduser && npm publish

    npm install [-g] $pkg@tag/version
    npm uninstall $pkg
    npm update [-g] $pkg
    npm search $pkg

    npm list -g  //查看安装的全局包的版本
    npm list $pkg //查看某个包的版本

    npm cache clear 清空本地缓存，用于使用相同的版本号发布

    npm unpublish $pkg@version 取消某版本的发布

    npm install -g cnpm --registry=https://registry.npm.taobao.org //淘宝的npm镜像

    npm run 可以查看package.json里有哪些可以通过npm run start|stop|test|dev|debug等命令

nodejs
    创建工程 cd projDir && npm init 会产生package.json文件
    添加依赖库  在package.json中的dependencies中添加 然后npm install 就可
    启动程序
        命令行 node --use_strict a.js  //让node为所有的js开启strict模式  这也是vscode launch.json文件中的配置
        命令行 npm start               //在package.json中配置"scripts": {"start": "node app.js"}

a.js
    // @ts-check 或者在jsconfig.json中添加{"compilerOptions": {"checkJs": true},"exclude": ["node_modules"]}
    //npm i @types/第三方库名  //为第三方库安装类型声明文件.d.ts

    数据类型
        bool    0 NaN null undefined
        Number  NaN  isNaN(NaN)
        string  多行时``  +  模板字符串`${x}`                    length  下标引用[0]/substring()      indexOf(str)

        array  [] new Array()  元素类型可以不同, 可以越组访问/赋值 length  下标引用[0]/slice([s[,e])    indexOf(ele)  push(...)/pop unshift(...)/shift() sort() reverse() concat(...,[1,2]) join('-') splice(s,e[,ele...])
        map       new map([[k1,v1],[k2,v2]]) has(k) get(k) set(k,v) delete(k)
        set       new set([v1,v2])                         add(v1)  delete(v1)

        Object  访问/赋值/新增o.field  删除delete o.field   判断field in o o.hasOwnProperty('field')

        null
        undefined

    运算符
        == ===
        if()else if(){}else{} for(;;)  while(){}  do{}whle()

        for(var i in arr){} //获取数组的索引i
        for(var f in o){} //获取所有属性f

    iterable  
        ES5.1
            forEach(function(ele, index, x){
                //arr ele index arr
                //set ele ele   set
                //map v   k     m
            })

        ES6
            for(var v of arr){}
            for(var kv of map){kv[0] kv[1]}
            for(var v of set){}

    解构赋值ES6
        数组
            let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]
            let [, , z] = ['hello', 'JavaScript', 'ES6']
        对象
            var person = {
                name: '小明',
                age: 20,
                gender: 'male',
                passport: 'G-12345678',
                school: 'No.4 middle school',
                address: {
                    city: 'Beijing',
                    street: 'No.1 Road',
                    zipcode: '100001'
                }
            };
            var {name, age, passport, single=true} = person //single有默认值true
            var {name, address: {city, zip}} = person;//address不是变量，而是为了让city和zip获得嵌套的address对象的属性
            let {name, passport:id} = person;// 注意: passport不是变量，而是为了让变量id获得passport属性:

    Function
        不定参数关键字arguments,rest
            function foo(a, b, ...rest){ //ES6引入了rest，表示其余的参数数组，当少参数时数组为null
                console.log(arguments.length) 
            }

        apply/call
            function.apply(obj, []) //obj为function中this的指向， 第二个参数为function的入参数组
            function.call(obj,...) //obj为function中this的指向， 第二个参数为function的入参数组的顺序传入

        高阶函数Hight-Order function： 函数的形参可以接受一个参数指针
            arr.Map(x=>{return x*1})           //对数组对象arr中的每个元素都调用箭头函数并返回新数组
            arr.reduce((x,y)=>{return x + y})
            arr.filter(function(ele){return true;}); //返回为true的
            arr.filger(function(ele, index, self){return self.indexOf(ele) === index;}) //数组去重
            arr.sort(function(x,y){if(x>y){return 1}else if(x<y){return -1}else{return 0;}}) //默认将ele转化为字符串按ascii排序
            arr.every(function(x){return x>1;}) //是否都>1
            arr.find(function(x){return x>1;})  //查询是否有大于1的元素并返回元素
            arr.findIndex(function(x){return x>1;}) //查询是否有大于1的元素并返回元素索引
            arr.forEach(console.log)
    异常
        try{

        }catch(e){
            console.log(e)
            throw new error("my err")
        }finally{

        }

    闭包

    产生器
        function* f(){yield x; return}
        var gen = f(5)  //产生一个generator
        gen.next()      //返回一个对象{value:x, done:true/false} x就是yield产生的 或 return返回的；  当是return直接返回时是value是undefined
        for (var x of f(5))

    标准对象
        Date  new Date()  Date.now()
        Json  Json.stringify(o,["f1", "f2"], '\t')  JSON.stringify(o, (k,v){}, '\t')  JSON.stringify(o)//优先调用o的toJson()成员函数
              JSON.Parse(o,(k,v){return v})
        RegExp

    面向对象
        var xiaoming = {}  xiaoming.__proto__ = Student  //xiaoming继承了Student

        var xiaoming = Object.create(Student)//根据Student原型创建对象 xiaoming有Student所有属性但为null  xiaoming.__proto__ === Student

        function Student(props){
            this.name = props.name
            this.grade = props.grade
            this.hello = function(){}  //每个对象都有一个hello函数
        }
        Stdent.prototype.hello = function(){} //在prototype中定义，则所有对象共享一个hello函数
        var xiaoming = new Student() //使用函数必须new默认返回this，否则返回undefined

        class ES6 需要Babel工具从class转换为prototype
            Class Base{
                constructor(name){
                    this.name = name
                }

                hello(){   //没有function
                    console.log(this.name)
                }

                this.byebye = function(){}
            }
            class Derived extends Base{
                constructor(name, age){
                    super(name)
                    this.grade = grade
                }

                myGrade(){}
            }
    








    作用域
        全局
            //在 HTML 中, 全局作用域是针对 window 对象
            //在 JavaScript 中, 全局作用域是针对 JavaScript 环境
            var x = 10    //使用 var 关键字声明的全局作用域变量属于 window 对象, 可以使用 window.carName 访问变量
            let x1 = 20   //使用 let 关键字声明的全局作用域变量不属于 window 对象, 不能使用 window.carName 访问变量
            {
                var x2 = 100 //不在函数体内，即使在{}内var修饰的仍然是全局变量
            }
            function foo(){
                y = 20       //函数体内没有var的一定是全局变量
            }
        块局
            {
                let x = 10
            }
            funtion foo(){
                var z = 1   //函数体内有var修饰的是局部变量
            }

    变量重置


    变量提升
        var可以  let不行



    


新建工程
    新建目录，切换到目录然后npm init, 产生package.json文件
引用
    引用具体的文件b.js中的export
        //export module.exports = {f1, f2}

        // var b = require("./b/b.js")
        // b.f1()
        // b.f2()

        module.exports = {
            k : require("./b.js")
        }

        var x = require("./b")
        x.k.f1()
        x.k.f2()
引用第三方库
    安装npm install -g date-fmt
调试
    点击最左边的调试，然后右边的setting，在编辑器上方弹出的地方选择node.js，然后产生launch.json文件，在里面的"program": "${workspaceFolder}\\a.js"，
    在具体的文件里行号左边点击添加断点





全屏  F11
sidebar ctrl+b
move up/down  alt+up/down

copy up/down  alt+shit+up/down
format        alt+shift+F




move line up/down       alt+shift+up/down
move statement up/down  ctrl+shift+up/down


浏览器  ctrl+shift+B



:%s/^\([A-Z]\)/#\1/g


https://www.ibm.com/developerworks/cn/linux/l-lpic1-v3-102-5/index.html
https://segmentfault.com/a/1190000011200461


Goland正版授权
812LFWMRSH-eyJsaWNlbnNlSWQiOiI4MTJMRldNUlNIIiwibGljZW5zZWVOYW1lIjoi5q2j54mIIOaOiOadgyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-ti4tUsQISyJF/zfWxSHCr+IcYrX2w24JO5bUZCPIGKSi+IrgQ0RT2uum9n96o+Eob9Z1iQ9nUZ6FJdpEW5g0Exe6sw8fLrWMoLFhtCIvVgQxEEt+M7Z2xD0esmjP1kPKXZyc/i+NCxA2EO2Sec9uifqklBGP1L3xoENAw2QsIWBfttIe6EPWhbS8TIMMr2vF/S3HrN8To5Hj5lwD/t1GHgFK1uWrhsuifAiKcVzqogybzGiR1h2+yNYTMbKxP7uPCcdYMsIyrBNVRGA3IuEJgyGQTQlFbnVQoVUTGPW2tQxprmC464wMjKi40JHh27WzjOHPwgzxDaigwn4Z0EbSpA==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==


/root/anaconda-ks.cfg
initial-setup-ks.cfg
original-ks.cfg        [anəˈkändə]  水蟒  kickstart 启动


查看文件系统类型
    cat /etc/fstab

    lsblk -f               #显示块设备
    blkid /dev/sda3        #打印查找块设备属性
    
    df -T -h               #只显示已挂载的,不显示未挂载的
    file -sL /dev/sda3    #标识文件类型 -s标志启用读取块或字符文件， -L启用以下符号链接

    parted && print list   #parted分区软件
    fsck -N /dev/sdb1      #打印和检查fs
    mount  | grep ^/dev

resize2fs更改文件系统的大小


ag advanced grep
fzf  
mycli             #mysql彩色客户端
shellchekc  a.sh  #检查shell语法

axel -n 20 $addr    多线程下载
lynx  --dump http://www.baidu.com  终端浏览器
tig git https://www.jianshu.com/p/e4ca3030a9d5
multitail
script/scriptreplay  终端会话录制并回放
top htop glances

zeal  dash
everything listary
Mockoon
chocolatey homebrew  


https://blog.csdn.net/u010625000/article/details/44455023


ag
    安装
        apt search silver
        apt search silver | grep search
        apt insall silversearcher-ag


fzf  fuzzy find 模糊查询 媲美vim的CtrlP插件
    安装
        apt install fzf 

        git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
        cd ~/.fzf && git pull && ./install

    使用
        keybinding bash zsh fish
            Ctrl-T  查找粘贴目录下的文件名或目录名到命令行
                vi Ctrl-T
                cd Ctrl-T
            Ctrl-R  查找粘贴选中的历史命令到命令行
                Ctrl-R  再按一次则在时间和相关性之间排序历史命令
            Ctrl-c  切换目录 == cd  + Ctrl-T
        autocomplete bash zsh
            kill -9/15 <tab>  然后tab或shift-Table选中

            vi $path/**<Tab>   vim $(fzf)
            cd $path/**<Tab>   cd $(find * -type d | fzf) 

            ssh **<tab>
            telnet **<tab>

            unset **<TAB>
            export **<TAB>
            unalias **<TAB>

        git分支
	        git checkout $(git branch -r | fzf)

        预览窗口  fzf --preview 'cat {}'

    快捷键 在输出交换窗口
        键盘 Ctrl-j/k/n/p   单选模式Enter选中     多选模式-m下Tab和shift-Table选中
        鼠标 滚轮滚动        单选模式双击选中      多选模式-m下Shift-Click或shift-scroll多选









apt install alien #可以在rpm dpkg deb之间转换
alien *.rpm
alien -r *.deb

*.rpm
*.src.rpm  包含未编译的原始代码,所以可以修改编译参数经过编译后才可以安装
            rpmbuild --rebuild    *.rpm   #build binary package from <source package>
            rpmbuild --recompile  *.rpm   #build through %install (%prep, %build, then install) from <source package> 

rpm格式
    Lead    公共
    signature
    header  软件包信息
    archive 文件列表

rpm -qil rpmdevtools

rpmdev-setuptree                        #与rpmdev-wipetree刚好相反
rpmdev-newspec -type python -o a.spec   #rpmdev-newspec --help 模板来自于/etc/rpmdevtools/spectemplate-*.spec 
rpmlint a.spec  &&  rpmlint -i a.spec   #检查spec语法错误    rpmbuild -E '%{_bindir}' tos.spec
rpmdev-newinit                 a.init   #制作服务控制脚本

目录结构
    SOURCES  *.tar.gz
    SPECS    *.spec

    BUILD               #config make
    BUILDROOT           #make install 产生x86_64

    RPMS    *.rpm       #将BUILDROOT打包
    SRPMS   *.src.rpm   #将BUILDROOT打包

rpmbuild
    常用选项
        --dbpath  ""             #默认值/var/lib/rpm
        --root    ""             #根目录

    编译前
        --nobuild                 #检出spec语法

    编译选项
        -bp %prep                 #解压缩并patch
        -bc       %build          #make
        -bi              %install #install 

        -bb                       #install之后只生成rpm          build binary package only from <specfile>        rpm
        -bs                       #           只生成src.rpm   
        -ba                       #                             build source and binary packages from <specfile> rpm src.rpm

        --buildroot ""
        --target i386 | i686 | x86_64
        --rmsource                #在build之后删除src.rpm 
        --rmspec                  #在build之后删除spec文件

    编译后
        --clean                  #删除build时的目录 BUILD/wget-1.14


spec
    定义变量  %define varname "xxx"
    引用变量  %{var}
    执行脚本  %( echo %{var} | sed 's///g' )
    定义宏    %global date 2012-02-08

    各种宏   cat /usr/lib/rpm/macros


    comments
    tags 变量定义
        包命名
            Name               不能含空格
            Version            不能含-
            Release
        描述  rpm -qpi *.rpm
            %description:      若以空格开始则逐字显示; 若不是以空格开始则对其段落划分 在变量定义中唯一个以%开头的变量
            Summary:  只能一行
            CopyRight: GPL 
            Lisence:  GPLv2 with exceptions
            Distribution:    软件集合
            Icon:            软件图标
            Vendor:          组织机构
            URL: 
            Group:
            Packager:    发包人的联系方式或公共的邮件列表
        依赖 rpm -qpi  --requires
            Provides     该包提供什么资源  既可以是一个真实存在的包,也可以只是一个虚拟的东西(仅仅是一个字符串)
            Requires     该包依赖哪些包 不支持不等于
                         = 1.2-2  >= > = <= < 
            conficts     该包与哪些包冲突
            serial       version之外的另外一种版本比较变量
            autoreqprov  自动生成软件依赖的标志位autorequire/autoprovide 取值为yes或者no,也可用0或1表示 默认值为yes或1 一般不用操作
        平台操作系统
            ExcludeArch: sparc alpha   不能在某CPU平台
            ExclusiveArch: aparc alpha 只能在某CPU平台
            ExcludeOS:  linux irix     不能在某OS
            ExclusiveOS: linux irix    只能在某OS
        目录
            prefix:  /opt  %files中声明为/opt/xx 在命令行的--prefix的优先级最高
            BuildRoot:  %{_topdir}/%{name}-%{version}-root 
        源码补丁
            Source:    源代码名称和存储位置
                Source:      #Source与Source0效果相同
                Source1:
                SourceN:
            NoSource:  从源代码中忽略一个或多个文件
            Patch:     标识源码的一个补丁文件
                Patch0:
                PatchN:
            NoPatch:   忽略一个或多个补丁
    script
        编译时
            %prep   为编译代码准备 1创建顶级目录 2解压源码到build目录 3如果有补丁的话打补丁

            %build   #####最多进行到configure && make 绝对不可能make install
            %ifarch cond1 cond2
                ./configure --with-ss=openssl
            %ifnarch cond1 cond2
            %ifos os1 os2 
            %ifnos os1 os2
                make RPM_OPT_FLAGS="$RPM_OPT_FLAGS -I . "
            %else
            %endif  

            %install  ####这儿才可以make install
            if [-d %{buildroot}]; then
                rm -rf %{buildroot}                              ← 清空下安装目录，实际会自动清除
            fi
            %{__install} -Dp -m0755 contrib/init.d %{buildroot}%{_initrddir}/foobar          
            make install prefix=$RPM_BUILD_ROOT/usr
            %{__install} -d %{buildroot}%{_sysconfdir}/foobar.d/   #对make install的目录结构进行修正,务必修正好 这样在%files可以直接打包

            %clean 
            [ "$RPM_BUILD_ROOT" != "/" ] && rm -rf $RPM_BUILD_ROOT
        安装到文件系统前/从文件系统卸载时
            %pre     第一个参数为1说明是初次安装,为2时是版本升级  hook默认使用bash来执行,但也可使用参数-p自定义
                %pre -p /usr/bin/perl 
                if ( $ARGV[0] == 1 ) {
                    print "preparing for init install\n"
                }
                elsif ( $ARGV[0] == 2 ) {
                    print "prepare to upgrade software\n"
                }
                添加group/user
            %post    第一个参数为1说明是初次安装,为2时是版本升级
                systemctl reload nginx.service
            %preun   第一个参数为0说明是卸载,为1时是版本升级
            %postun  第一个参数为0说明是卸载,为1时是版本升级

            升级流程
                执行新版本的%pre 
                安装新版的文件列表
                执行新版本的%post

                检查所有其他rpm包的triggerin触发器,如果有被N的安装触发,就执行相应脚本
                执行N的所有triggerin触发器
                执行N的所有triggerun触发器

                检查所有其他rpm包的triggerin触发器,如果有被N的卸载触发的,就执行相应的脚本

                执行老版本的%preun
                自动删除老版本中没有被新版本覆盖的文件
                执行老版本的%postun
        校验时          用rpm命令校验已安装的rpm时执行 rpm -qpVv *.rpm
            %verifyscipt  因为rpm默认会校验文件列表,所以不用去校验,因此这儿可以做点自己想做的 默认不会执行%verifyscipt,除非使用verbose模式进行校验
            echo "verify aaa" 
        触发器Trigger   被一定的条件(如其他rpm安装或卸载)触发执行
            B%triggerin A包安装时,如果B包已经安装,则触发该触发器
            B%triggerun A包安装时,如果B包已经卸载,则触发该触发器
            B%triggerpostun A包安装时,如果B包被卸载,则卸载完成后触发该触发器

            eg:
                %triggerin -p /usr/bin/perl -- ruby   #通过--符号指定被监控的包
                # print "ruby already installed"
    Macro 宏
        %setup      解压缩源码  多数情况下不用任何选项
            -n $name 设置编译目录名默认是name-version
            -c $build_dir_name  创建build目录并进入该目录
        %patch      给解压后的源码打补丁
    files 文件列表指令Directives 设置与检查文件/目录/软件包的属性 rpm -qf /etc/x.conf
        文件相关
            %doc    用来标识一个文件是文档 安装后会被rpm数据库记录 默认安装目录是/usr/doc 可以通过修改rpmrc中的defaultdocdir变量的值来修改
            %config 用来标识一个文件是配置文件 设置了noplace属性后 rpm在升级时就不会被覆盖 在卸载时会被保存为x.save  rpm -qp *.rpm --configfiles
                %config(noreplace) /etc/x.conf
            %attr   用来修改文件属性(默认权限 属主 属组)指令
                %attr (755, root, root) foo.bar
            %verify 校验指令
        目录相关
            %docdir /absolute-dir-path  用于指定配置文件目录
            %dir    /absolute-dir-path  用于只将目录打包  默认将目录下的文件及文件夹打包

        %package -n $new_sub_package_name 定义子包名,默认命名是"基础包-子包"格式

        eg
            %files                   ######## 对%install中的目录进行摘选
            %defattr (-,root,root,0755)                         ← 设定默认权限
            %attr(755, root, root) %{_sbindir}/mysqld
            %config(noreplace) /etc/my.cnf                      ← 表明是配置文件，noplace表示替换文件
            %attr(644, root, root) %{_mandir}/man8/mysqld.8*    ← 分别是权限，属主，属组
            %doc %{src_dir}/Docs/ChangeLog                      ← 表明这个是文档



全局配置      /etc/yum.conf                设置如何管理源repo
源配置文件    /etc/yum.repos.d/*.repo      源的配置文件
本地rpm数据库 /var/lib/rpm/_db.*           存储系统已安装了哪些rpm   /var/lib/yum
本地缓存      /var/cache/yum/*             存储索引文件和rpm文件
插件          /usr/lib/yum-plugins/fastestmirror.py       fastestmirror对每个mirror进行测速,然后根据连接速度排序站点速度,选择下载速度最快的站点下载
插件配置文件   /etc/yum/pluginconf.d/fastestmirror.conf
日志          /var/log/yum.log 


rpmbuild -ba main.spec 
yum install *.rpm 
rpm -ql main 
rpm -qi main 


cd BUILD
tar -zxvf $Source.tar.gz      #$Source来自*.spec中的Source
%build                        #执行spec中的%build
rm -rf   $Name-$Version &&    #Name和Version来自*.spec 
mkdir -p $Name-$Version 
%install                      #执行spec中的%install
打包


索引读写分离
缓存
镜像
智能DNS和多机房容灾


/root/anaconda-ks.cfg
initial-setup-ks.cfg
original-ks.cfg        [anəˈkändə]  水蟒  kickstart 启动


查看文件系统类型
    lsblk -f               #显示块设备
    cat /etc/fstab
    df -T -h               #只显示已挂载的,不显示未挂载的
    parted && print list   #parted分区软件
    fsck -N /dev/sdb1      #打印和检查fs
    blkid /dev/sda3        #打印查找块设备属性
    mount  | grep ^/dev
    file -sL /dev/sda3    #标识文件类型 -s标志启用读取块或字符文件， -L启用以下符号链接

    fdisk -l 只能列出硬盘的分区表、容量大小以及分区类型，但看不到文件系统类型


cal [[[day] month] year]


ag advanced grep
fzf  vim $(fzf)        fuzzy finder
	 cd $(find * -type d | fzf) 
	 git checkout $(git branch -r | fzf)
shellchekc  a.sh  检查shell语法
mycli mysql彩色客户端
axel -n 20 $addr    多线程下载
tig git https://www.jianshu.com/p/e4ca3030a9d5
multitail
script/scriptreplay  终端会话录制并回放
top htop glances
lynx  终端浏览器








https://blog.csdn.net/u010625000/article/details/44455023


全部摘抄 http://www.berlinix.com/gdb.html
http://www.docin.com/p-245963860.html
https://developer.apple.com/library/mac/#documentation/DeveloperTools/gdb/gdb/gdb_9.html  
http://www.douban.com/note/65837435/

gdb的配置文件是.gdbinit.就如vi的.vimrc.

break       b
delete      d
disassemble disas
info        i
registers   r
只有break和watch命令支持if，catch目前暂不支持if.


0、写在前头
产生core：              
                            limit -c                             #查看
                            limit -c unlimited/1024*1024*1024    #设置，防止消耗内存大的进程产生过大的coredump
配置     
                            kernel.core_pattern=/var/core/%t-%e-%p-%c.core   #cat /etc/sysctl.conf
                            kernel.core_uses_pid=0                           #若为1，即在core文件后加上pid，但上面我们已经加上了pid了
                            sysctl -p
编译                    <Esc>:make {arguments}  #编译代码
                           <Esc>:gr[ep] main *.c     #
遍历编译错误             http://man.chinaunix.net/newsoft/vi/doc/help.html 查找    quickfix.txt文档    
                            http://man.chinaunix.net/newsoft/vi/doc/usr_30.html#usr_30.txt
                           <Esc>:cl[ist]                          #只有那些含有文件名或行数的错误信息才会被显示。vim假定你对其他信息不感兴趣
                           <Esc>:c[list]! [from][,[to]]           #查看所有的make的信息,只需在上述命令上加！
                           <Esc>:cfir[st]                         #将光标移动到第一个错误
                           <Esc>:cl[ast]                          #将光标移动到最后一个错误
                           <Esc>:cp[revious]                      #将光标移动到上一个错误
                           <Esc>:cN[ext]                          #将光标移动到下一个错误所在的行
			       <Esc>:cc                              #有时空间不够，vim会缩短出错信息。如果想查看详细信息
                           <Esc>:cc 3                             #将光标移动到第三个错误
                           <Esc>:cope[n] [height]                 #打开一个窗口显示当前的错误列表.默认为10行高。一般位于底端。如果有垂直分割，会位于最右边窗口的最下边。
                           <Esc>:ccl[ose]                         #关闭quickfix窗口
                           <Esc>:cw[indow] [height]               #当存在可以识别的错误时，打开此窗口。如果该窗口已经打开且没有可以识别的错误，则将此窗口关闭

1、启动调试
gdb ./prog                                  #debug from start
gdb ./prog pid                              #debug running prog
gdb ./prog core                             #debug core file

server：gdbserver host:port --attatch PID
        gdbserver clientIP:serverPort Prog
client：gdb Prog
        (gdb)target remote serverIP:serverport
        (gdb)list/break
        (gdb)continue/c                    #不能run因为Prog已经在server上run了
        (gdb)以后如常

2、gdb shell 命令
宏
(gdb)info macro macro-name
(gdb)macro expand macro-name                #展开宏         http://blog.chinaunix.net/space.php?uid=23629988&do=blog&id=3053595
                                                            默认级别是-g2，简称-g,此时不能expand macro，需要-g3,产生更多的调试信息
                                                            对于单个文件，可以采取预编译 g++ -E test.c > test.e，查看宏定义，include文件
加载
(gdb)file [/path/to/]$(prog)                #加载prog符号文件即加载应用程序
(gdb)info files
(gdb)set args $(argv[1]) $(argv[2])         #设置应用程序参数    
(gdb)show args
(gdb)info args
(gdb)path <dir>                             #程序的运行路径
(gdb)show path                              #查看程序的运行路径
(gdb)set environment varname[=value]        #设置环境变量
(gdb)show environment [varname]             #查看环境变量

源代码   
编译的时候一定要加上-g参数，表示将源代码编译到执行文件，否则看不到路径和源代码
编译-g的时候，只包括了源代码的文件名，没有提供源代码的路径
总结：-g 表示将源代码编译到可执行文件，但看不了源代码，只能看到文件名，所以这时必须提供源代码路径
     但由于一般在调试的情况下有2个预制变量$cdir:$cwd，其中cwd表示当前路径，cdir表示compilation dir
       而由于一般调试在源码目录下，此时cwd就表示源码目录
       当将即使以-g编译的exe拷贝到别的机器，由于cwd没有源码，所以必须拷贝源码过去，且设置directory
Add directory DIR to beginning of search path for source files.  
Forget cached info on source file locations and line positions.  
DIR can also be $cwd for the current working directory, or $cdir for the  
directory in which the source file was compiled into object code.  
With no argument, reset the search path to $cdir:$cwd, the default.
(gdb)show directories                        #源代码搜索路径
(gdb)directory /path/to/src_dir1:/path/to/src_dir2 # http://coolshell.cn/articles/3643.html
     或分成多步directory /path/to/src_dir1          # https://sourceware.org/gdb/onlinedocs/gdb/Source-Path.html
       directory /path/to/src_dir2
                                             #添加源代码搜索路径在当前路径的前面.默认搜索路径是环境变量PATH中定义的路径。
                                             #如果需要指定多个路径，unix可以使用":"或whitespace,windows使用"；"
(gdb)director                                #清除所有自定义的原文件搜索路径
(gdb)set listsize <count>
(gdb)show listsize
(gdb)list <linenum>                          #显示程序第linenum行周围的代码
(gdb)list <function>                         #显示函数名function的源代码
(gdb)list                                    #显示当前行后的代码，默认是10行，当前行的前5和后5，函数则为前2下8
(gdb)list +                                  #显示当前行后的代码
(gdb)list -                                  #显示当前行前的代码
(gdb)list <first>,<last>                     #显示first行到last行的代码
(gdb)list <last>                             #显示当前行到last行之间的代码
(gdb)search/forward-search <reg>
(gdb)reverser-search <reg>
断点
在gdb中有以下几种暂停方法：
断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops）
(gdb)b/break <fileName:linenum> [if  ]       #b x.cpp:15 在文件x.cpp的15行处设置断点
(gdb)break/b <fileName:function>
(gdb)break/b <linenum>                       #在当前文件的linenum停住
(gdb>break/b +<offset>                       #在当前行的后面offset行停住
(gdb)break/b -<offset>                       #在当前行的前offset行停住
(gdb)b <class::function|function(type,type>  #b main
(gdb)b *function-name                        #b *main
(gdb)b *address                              #在地址address处设置断点 b *0x804835C
(gdb)rb                                      #对符合正则表达式的位置处设置断点
                                             #若不带参数，则在所有位置处设置断点
(gdb)info b                                  #查询所有断点
(gdb)disable                                 #默认所有断点失效
(gdb)disable/enable $(id1) $(id2)            #enable/disable breakpoint
(gdb)condition $(breakpoint1) $(expression)  #修改breakpoint的停止条件为expression
(gdb)condition $(breakpoint1)                #清除断点号breakpoint1的停止条件
(gdb)ignore $(breakpoint1) $(number)         #从现在起忽略breakpoint$(number)次
(gdb)delete/d [$(id1)]                       #删除断点
(gdb)                                        #为断点设置运行命令command
(gdb)break string::after                     #断点菜单。当有函数重载时，break <function>不能告诉gdb停止在哪儿(当然，详细的函数原型可以定位).
                                             #此时，gdb会为你弹出一个菜单，提示在哪儿可以设置断点。
                                             #选择0表示取消设置断点，
                                             #亦可以同时选择多项数字，中间用空格间隔
(gdb)break <linespec> thread <threadno> if …#注意，这个threadno是GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。
                                             #当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体情况。
                                             #而在你恢复程序运行时，所有的线程也会被恢复运行。那怕是主进程在被单步调试时。
运行
(gdb)run/r [argv[1] argv[2] ... argv[n]]#重新启动程序运行restart run
(gdb)continue/c/fg [ignore-count]            #continue/c/fg三个命令一样，ignore-count表示忽略断点的次数
                                             #next/step这两个命令必须在有源代码调试信息的情况下使用(即GCC编译时使用-g参数）
(gdb)next/n  [count]                         #next  count表示执行后面的count条指令再停住          
(gdb)step/s  [count]                         #step into function，前提是函数有debug信息。count表示执行子函数里的count条指令再停住。
(gdb)ni/nexti                                #执行一条机器指令  ni/si针对的是汇编指令
(gdb)si/stepi                                #执行一条机器指令
(gdb)finish                                  #运行程序，直至退出当前函数。并打印函数返回时的堆栈地址和返回值及参数值信息。
(gdb)until/u                                 #退出循环体
(gdb)set step-mode on                        #默认值是on。打开step-mode模式。于是在单步跟踪的时候不会因为没有debug信息而不停住。
                                             #这个参数很有利于查看机器源码
(gdb)set step-mode off
栈/帧
(gdb)bt [full]                               #显示局部变量
(gdb)bt [full]  <n>                          #只打印栈顶n层
(gdb)bt [full]  <-n>                         #只打印栈底n层
(gdb)f/frame                                 #check where you are
(gdb)f/frame $(fNum)                         #0表示栈顶
(gdb)info frame/f
查看
(gdb)display ...                             #设置程序中断后欲显示的数据及其格式。 http://hi.baidu.com/foxiong/blog/item/cf448dd67d40d02e06088b74.html
                                             #例如，希望程序每次中断后可以立即看到即将被执行的下一条汇编指令，可以使用
                                             #(gdb)display /i $pc   其中 /i表示以十六进制显示  $pc表示当前的指令
                                             #当需要关心汇编指令时，此命令相当有用
(gdb)undisplay 
查看变量
(gdb)info args                               #查看函数参数
(gdb)info locals                             #查看局部变量
(gdb)info registers                          #查看寄存器
(gdb)info catch                              #查看当前函数中的异常处理信息
(gdb)i r                                     #与上述等价  查看寄存器
查看类型
(gdb)ptype $(val)
(gdb)whatis $(val)                           #查看变量类型
查看寄存器
(gdb)info registers                          #查看寄存器(除了浮点寄存器)
(gdb)info all-registers                      #查看所有的寄存器(包括浮点寄存器)
(gdb)info registers <regname...>             #查看所有指定的寄存器    或 print/p $ip加上$
                                             #ip:当前运行指令的地址 sp:当前堆栈地址 
打印计算表达式
(gdb)set print pretty on
(gdb)print/p [/f] <expresssion>              #gdb会根据当前的程序运行的数据来计算表达式。
                                             #/f format的取值范围 x:16进制 d/u:10进制 o:8进制 t:2(two)进制 a:address c:AsciiChar s:string f:float
                                             #既然是表达式，那么可以是当前程序运行的const变量、变量、函数等，可惜不能是宏。
                                             #	@与数组有关
                                             #  ::指定一个在文件file::variable或函数func::variable中的变量，
                                                   注意与C++的::的区别,还有可能被编译器优化掉某些变量，建议调试时关闭优化选项即-O0
                                             #  {<type>} <addrss> 表示一个指向内存地址<address>的类型type的一个对象
(gdb)p *arrar@len                            #print arrar=(int*)malloc();//set print element 0 默认最长是200个字节
(gdb)p/x (unsigned int[])out                 #强转为unsigned int数组并以16进制打印
查看内存
(gdb)help x
(gdb)examine/x [/nfu] <address>              #n f u 是可选参数 如x /20b $addr
                                             #n number是一个正整数，表示显示内存的长度，也就是说从当前地址address后显示n个地址的内容
                                             #f format表示显示格式。如果地址所指的是字符串，那么格式是s；如果地址是指令地址，那么格式是i
                                             #u unit  表示从当前地址往后请求的字节数。如果不指定的话，gdb默认是4个字节。
                                             # u可以使用下面的字符来代替，b表示单字节，h表示双字节，w表示4个字节，g表示8个字节
                                             # x/3uh 0x54320  从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示
观察点
(gdb)watch $(v)                              #为变量v设点断点，当v被写时stop
(gdb)awatch $(v)                             #为变量v设点断点，当v读或写时stop
(gdb)rwatch $(v)                             #为变量v设点断点，当v被读时stop
设置变量
(gdb)set var = 5                             #设置程序变量
(gdb)set $var = 5                            #设置gdb变量,gdb中的变量以$开头，之后就可以print a[$var++]
自动显示                                  #在gdb中，你可以设置当程序停在断点处时，自动显示变量的内容，即display命令
(gdb)info display
(gdb)display <expr>                          #只要gdb停下来的时候，自动显示的变量
(gdb)display <fmt> <expr>
(gdb)display /<fmt> <addr>
(gdb)display /i $pc                          #$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。
                                             #   于是当程序停下后，就会出现源代码和机器指令码相对应的情形
(gdb)disable/enable display <dnums>
(gdb)undisplay/delete <dnums>                #undisplay 2-5
调用函数
(gdb)call ntohs(10275)                       #调用函数
源代码的内存指令
可以使用info line命令查看源代码行在内存中的起始地址。
info line后可接"linenum","function-name","filename:linenum","filename:functin-name".
(gdb)help info line
(gdb)info line main.c:5                   #默认显示当前行
Line 8 of "main.c" starts at address 0x4004ae <main+22> and ends at 0x4004b2 <main+26>.
在此后，有两种方法查看汇编layout asm或disassemble /r
(gdb)layout asm                           #注意[main+22,main+26)
(gdb)disassemble /r 0x4004ae,0x4004b2     #好像只有gdb7.0才支持/r
(gdb)disassemble /m 0x4004ae,0x4004b2     #会列出源码并汇编
汇编
(gdb)set disassemble-flavor intel/att        #设置反汇编风格
(gdb)show disassembly-flavor                 #查询反汇编风格，可以是intel/att
(gdb)disassemble/disas                    #默认的反汇编范围是所选帧的pc附近的函数
(gdb)disassemble pc/function-name            
(gdb)disassemble /r <begin-addr,end-addr>

(gdb)info/i program                          #find out why your program stopped
改变程序的执行
(gdb)p var = 5                               #设置程序变量并打印
(gdb)jump <linenum>                          #跳转到哪一行执行
(gdb)jump <file-name:linenum>
(gdb)jump +lineoffset
(gdb)jump <address>                          #代码行的内存地址
(gdb)return                                  #强制函数返回
(gdb)return <expression>                     #强制函数返回expression
(gdb)call <expr>                             #显示函数的返回值，如果返回值是void，那么就不显示。
                                             #与print类似，如果函数返回void，call则不显示；print则显示返回值，并把数据存到历史数据中。
历史
(gdb)history
(gdb)show commands 20                        #显示命令的历史记录
联调
(gdb)attach $(pid)                           #等价于gdb -p $(pid)
信号
(gdb)info signals                            #查看信号处理方式
(gdb)info handle                             #查看有哪些信号被gdb检测中
(gdb)handle <signal> <keywords...>       #改变gdb对信号signal的处理方式
						    #  可以以SIG开头或不以SIG开头；
                                             #	也可以定义一个范围SIGIO-SIGKILL,表示包括SIGIO,SIGIOT,SIGKILL三个信号
                                             #  也可以使用关键字all，表明需要处理所有的信号
                                             #keywords，可以是下面关键字的组合，实质上就3列： stop/nonstop print/nonprint pass/nopass
                                             #	nonstop 当被调试的程序收到信号时，gdb不会停住程序的运行，但会打印信息，表示收到这种信号
                                             #  stop    当被调试的程序收到信号时，gdb会停住程序
                                             #  print/noprint 当被调试的程序收到信号时，gdb是否会打印信息
                                             #  pass/noignore   当被调试的程序收到信号时，gdb不处理信号。这表示gdb会把这个信号交给程序处理
                                             #  nopass/ignore  当被调试的程序收到信号时，gdb不会让被调试的程序处理信号
                                             # 例如： handle SIGINT nostop print pass
(gdb)handle SIGNAL nopass/ignore             #不将信号signal传递给程序  
                     pass/ignore             #allow program see this signal
(gdb)signal <signal-number>             #发送信号给被调试程序。
                                             #signal命令与shell的kill命令不同，kill时由gdb截获，signal直接发送给被调试应用。
                                             #signal-number范围是1-15.unix的系统信号通常在1,-15，所以signal也在这个范围
捕捉点                                    #必须在程序处于run状态
(gdb)help catch                          
(gdb)catch <event>                           #throw一个C++的异常(throw为关键字)
                                             #catch一个C++的异常(catch为关键字)
                                             #exec系统调用(exec为关键字，目前只有HP-UX下有用)
                                             #fork系统调用(fork为关键字，目前只有HP-UX下有用)
                                             #vfork系统调用(vfork为关键字,目前只有HP-UX下有用)
                                             #load或load <libname>(load为关键字，目前只有HP-UX下有用)
                                             #unload或unload <libname>(unload为关键字，目前只有在HP-UX下有用)
(gdb)tcatch <event>                          #只设置捕捉一次，当程序停住后，断点被自动删除
设置显示项
(gdb)show print address                      #
(gdb)set print address on/off                #当gdb调用函数的时候，是否显示参数的地址，默认显示
(gdb)show print array
(gdb)set print array on/off                  #当打印数组时，on表示每个元素一行，off则每个元素以逗号分隔。默认off
(gdb)show print elements
(gdb)set print elements <number-of-elements> #设置打印数则时的最大个数，0表示不限制
(gdb)set print null-stop on/off              #on表示显示字符串时，遇到结束符就停止显示。默认off
(gdb)show print pretty                       #如何显示结构体
(gdb)set print pretty on/off                 #on显示比较漂亮 off单行显示
(gdb)show print sevenbit-strings             #设置字符是否按\nnn的格式显示
(gdb)set print sevenbit-strings on/off       #on表示字符串或字符数据按\nnn显示。如\065
(gdb)show print union                        #查看联合体的显示格式
(gdb)set print union on/off                  #设置显示结构体时，是否显示其内的联合体数据
(gdb)show print object                       #查看对象选项的设置
(gdb)set print object on/off                 #在C++中，如果一个对象指针指向其派生类，
                                             #如果on，gdb会自动按照虚方法调用的规则显示输出
                                             #如果off，gdb就不管虚函数表了。 默认off
(gdb)show print static-members               
(gdb)set print static-members on/off         #当显示一个c++对象的内容时，是否显示其中的静态数成员。默认是on
(gdb)show print vtbl
(gdb)set print vtbl on/off                   #是否显示虚函数.默认是off
环境变量
(gdb)show convenience                        #查看所有的环境变量
(gdb)set $v1=x
自动化命令command                         # http://coolshell.cn/articles/3643.html
    (gdb) b func
    (gdb) command 1                          #command 后接breaknumber,每行命令分行，最后以end结束
     >print arg1
     >print arg2
     >print arg3
     >end
    (gdb)
3、调试C++
gdb调试C++，涉及到STL容器查看，非常麻烦。 有一个GDB STL Viewer(http://www.berlinix.com/code/gdb_stl_viewer.txt)的脚本，可以帮助查看STL容器。 
只需在调用gdb后，执行命令source gdb_stl_viewer.txt加载它即可。
b 'C::foo                   自动补全'
ptype C                     显示类C的声明
info functions C::foo       显示类C的所有foo函数声明
在模板函数中的某一行设置断点，将导致gdb只在某个模板实例中中断。 通过info b查看，如:
breakpoint     keep y   0x08048774 in void print<char>(char) at tem.cpp:8
必须在函数签名，而非源代码某一行设置断点，如有模板函数 print<T> 要打断点，可通过：
i) 通过命令 objdump -tC ./tem|grep print 
    或 objdump -t ./tem|c++filt|grep print                  #c++ filter http://book.51cto.com/art/201005/197760.htm
    找出所有print符号。
ii)在gdb中对这些符号下断点。如 b void print<int>(int)

4、配置文件
vim ~/.gdbinit                               #新建gdbinit文件
source ~/gdb_stl_viewer.txt                  #添加gdb命令

define commond-name                          #gdbinit定义命令语法
commands
end

document command-name                        #给命令添加说明性文字
desc
end

5、调试多线程
(gdb)info threads                             #inquire threads
(gdb)thread $(tid)                            #switch among threads
(gdb)thread apply all bt                      #显示所有的线程堆栈              pstack 
(gdb)thread appy $(tid1) $(tid2) bt           #显示tid1, tid2的堆栈。bt可以换成其他任何gdb命令
(gdb)set scheduler-locking off|on|step
			                         #off不锁定任何线程。在调试某一线程时，其他线程照常执行。默认。
			                         #on锁定其他线程，只有当其线程会执行。
			                         #step除了next过一个函数的情况，step只让当前线程执行。
(gdb)break <line> [thread <threadno>] [if ...]#line  filename:linenum
                                              #threadno 是info threads最左边的序号0,1,2而不是大数 
6、调试多进程
(gdb)set detach-on-fork off                   #both parent/child process will be held under the control of gdb
(gdb)set follow-fork-mode child/parent        #default跟踪parent
(gdb)info forks                               #显示所有进程pid
(gdb)process $(pid)                           #切换到pid的进程
(gdb)fork $(fork-id)                          #切换到fork-id的进程，类似process pid,但该fork-id类似于frame id，是最前面的序号0，1，2,...

7、bookmark/checkpoint                        http://blog.chinaunix.net/space.php?uid=23629988&do=blog&id=2943273
(gdb)checkpoint                               #save a snapshot
(gdb)info checkpoints
(gdb)restart $(checkpoint-id)                 #wind back the clock

8、hook
给gdb定义钩子，使其在执行gdb命令前、后，执行用户自定义的命令
define hook-print           # 命令必须是全称，不能为缩写
echo --\n
end
define hookpost-print       # 在命令后执行用户指令
echo --\n
end

9、kgdb
kgdb可对Linux内核进行内核级别源码调试。需要两台机子，用串口相连(或在VMware里模拟串口通讯)。 kdb不能进行内核源码基本调试，但可以只用一台机子。





当进程不正常（死锁），但没有产生coredump，而生产环境又不允许gdb，则需要强制产生coredump：
kill -(SIGQUIT/SIGABRT/SIGFPE/SIGSEGV) $pid
还有一种情况，进程并没有死锁或者block在某个位置，但是我们需要在某个指定位置进行调试，获取某些变量或者其它信息。但是，有可能是客户环境或者生产环境，不允许我们进行长时间的检测。那么，我们就需要通过coredump来获得进程在运行到该点时的快照。这个时候，可以利用gdb来产生手工产生coredump。在attach上这个进程时，在指定位置打上断点，当断点触发时，使用gdb的命令gcore，可以立即产生一个coredump。这样，我们就拿到了这个位置的进程快照。



gdb -help
(gdb)help                      #列出类别
(gdb)help $(class_type)        #
(gdb)b\t\t                     #连续按两次tab键，可以显示候选命令或匹配的函数名
(gdb)shell <command string>    #在gdb中执行shell
(gdb)gcore                     #强制产生coredump




远程调试
情景：
目标机(Server)：192.168.1.241:1100  #在端口1100监听  
调试机(Client): 192.168.1.244
应用程序：a.out
步骤
(1)目标机先启动：
$gdbserver 192.168.1.244:1100 a.out
(gdb) Process a.out created;pid=5384
Listening on port 1100
(2)在客户机：
$gdb a.out
(gdb)target remote 192.168.0.241:1100
Remote debugging using 192.168.1.241:1100



$gdb main
(gdb)layout asm
(gdb)help x             #查看内存
Examine memory: x/FMT ADDRESS.
ADDRESS is an expression for the memory address to examine.
FMT is a repeat count followed by a format letter and a size letter.       [repeat-count]   默认值为1 
Format letters are o(octal), x(hex), d(decimal), u(unsigned decimal),      [format]         
  t(binary), f(float), a(address), i(instruction), c(char) and s(string).  [size]           b(byte) h(halfword) w(word) g(giant 8bytes)
Size letters are b(byte), h(halfword), w(word), g(giant, 8 bytes).
The specified number of objects of the specified size are printed
according to the format.

Defaults for format and size letters are those previously used.
Default count is 1.  Default address is following last thing printed
with this command or "print".






插件：
调试STL
    下载http://www.yolinux.com/TUTORIALS/src/dbinit_stl_views-1.03.txt
    cat dbinit_stl_views-1.03.txt >> ~/.gdbinit
    若正处于gdb状态,运行(gdb)source ~/.gdbinit
    查看帮助(gdb)help pvector 或查看源码dbinit_stl_views-1.03.txt 






$ apt-get source coreutils
$ sudo apt-get install coreutils-dbgsym
$ gdb /bin/ls
GNU gdb (GDB) 7.1-ubuntu
(gdb) list main
1192    ls.c: No such file or directory.
in ls.c
(gdb) directory ~/src/coreutils-7.4/src/
Source directories searched: /home/hchen/src/coreutils-7.4:$cdir:$cwd
(gdb) list main
1192        }
1193    }
1194
1195    int
1196    main (int argc, char **argv)
1197    {
1198      int i;
1199      struct pending *thispend;
1200      int n_files;
1201

















5.3 Signals 
A signal is an asynchronous event that can happen in a program. The operating system defines the possible kinds of signals, and gives each kind a name and a number. For example, in Unix SIGINT is the signal a program gets when you type an interrupt character (often C-c); SIGSEGV is the signal a program gets from referencing a place in memory far away from all the areas in use; SIGALRM occurs when the alarm clock timer goes off (which happens only if your program has requested an alarm). 

Some signals, including SIGALRM, are a normal part of the functioning of your program. Others, such as SIGSEGV, indicate errors; these signals are fatal (they kill your program immediately) if the program has not specified in advance some other way to handle the signal. SIGINT does not indicate an error in your program, but it is normally fatal so it can carry out the purpose of the interrupt: to kill the program. 

GDB has the ability to detect any occurrence of a signal in your program. You can tell GDB in advance what to do for each kind of signal. 

Normally, GDB is set up to let the non-erroneous signals like SIGALRM be silently passed to your program (so as not to interfere with their role in the program's functioning) but to stop your program immediately whenever an error signal happens. You can change these settings with the handle command. 


info signals 
info handle 
Print a table of all the kinds of signals and how GDB has been told to handle each one. You can use this to see the signal numbers of all the defined types of signals. 
info handle is an alias for info signals. 


handle signal keywords... 
Change the way GDB handles signal signal. signal can be the number of a signal or its name (with or without the `SIG' at the beginning); a list of signal numbers of the form `low-high'; or the word `all', meaning all the known signals. The keywords say what change to make. 
The keywords allowed by the handle command can be abbreviated. Their full names are: 


nostop 
GDB should not stop your program when this signal happens. It may still print a message telling you that the signal has come in. 

stop 
GDB should stop your program when this signal happens. This implies the print keyword as well. 

print 
GDB should print a message when this signal happens. 

noprint 
GDB should not mention the occurrence of the signal at all. This implies the nostop keyword as well. 

pass 
noignore 
GDB should allow your program to see this signal; your program can handle the signal, or else it may terminate if the signal is fatal and not handled. pass and noignore are synonyms. 

nopass 
ignore 
GDB should not allow your program to see this signal. nopass and ignore are synonyms. 
When a signal stops your program, the signal is not visible to the program until you continue. Your program sees the signal then, if pass is in effect for the signal in question at that time. In other words, after GDB reports a signal, you can use the handle command with pass or nopass to control whether your program sees that signal when you continue. 

The default is set to nostop, noprint, pass for non-erroneous signals such as SIGALRM, SIGWINCH and SIGCHLD, and to stop, print, pass for the erroneous signals. 

You can also use the signal command to prevent your program from seeing a signal, or cause it to see a signal it normally would not see, or to give it any signal at any time. For example, if your program stopped due to some sort of memory reference error, you might store correct values into the erroneous variables and continue, hoping to see more execution; but your program would probably terminate immediately as a result of the fatal signal once it saw the signal. To prevent this, you can continue with `signal 0'. See section Giving your program a signal.







































ln -s $sym_link  $entity  # sym_link --> $entity


cp    $sym_link $v        # cp $entity $v       拷贝链接指向的对象
cp -d $sym_link $v        # $v ---> $entity   d 单纯拷贝链接


a   ==dpR                       复制属性
d   拷贝时保存链接
p   将修改时间和访问权限也复制
R   递归
l   链接文件，不作拷贝
i   若存在则提示
f   若存在，先删除，再复制














































strace –tt –p –e –o a.txt
strace -f -s 100 ./test
strace -f -p $pid -s 600
strace -e rt_sigaction -f -s 100 ./test


-f/-F  跟踪fork/vfork
-p $pd 跟踪进程$pid
-e     
-s
-tt 
-o    输出文件





 1.挂死程序源码
//hang.c
#include
#include
#include
#include

int main(int argc, char** argv)
{
    getpid(); //该系统调用起到标识作用
    if(argc < 2)
    {
        printf("hang (user|system)\n");
        return 1;
    }
    if(!strcmp(argv[1], "user"))
        while(1);
    else if(!strcmp(argv[1], "system"))
        sleep(500);
    return 0;
}

可向该程序传送user和system参数，以上代码使用死循环模拟用户态挂死，调用sleep模拟内核态程序挂死。


2.strace跟踪输出

用户态挂死跟踪输出：

lx@LX:~$ gcc hang.c -o hang

lx@LX:~$ strace ./hang user

……

mprotect(0x8049000, 4096, PROT_READ)    = 0

mprotect(0xb59000, 4096, PROT_READ)     = 0

munmap(0xb77bf000, 80682)               = 0

getpid()                                = 14539

内核态挂死跟踪输出：

lx@LX:~$ strace ./hang system

……

mprotect(0x8049000, 4096, PROT_READ)    = 0

mprotect(0xddf000, 4096, PROT_READ)     = 0

munmap(0xb7855000, 80682)               = 0

getpid()                                = 14543

rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0

rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0

rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0

 

nanosleep({500, 0},

3.输出分析

用户态挂死情况下，strace在getpid()一行输出之后没有其他系统调用输出；进程在内核态挂死，最后一行的系统调用nanosleep不能完整显示，这里nanosleep没有返回值表示该调用尚未完成。

 

因而我们可以得出以下结论：使用strace跟踪挂死程序，如果最后一行系统调用显示完整，程序在逻辑代码处挂死；如果最后一行系统调用显示不完整，程序在该系统调用处挂死。

 

当程序挂死在系统调用处，我们可以查看相应系统调用的man手册，了解在什么情况下该系统调用会出现挂死情况。

下次再遇到程序挂死、命令执行报错的问题，如果从程序日志和系统日志中看不出问题出现的原因，先别急着google或找高手帮忙，别忘了一个强大的工具它就在那里，不离不弃，strace一下吧！




 starce 的另一个用处是解决和动态库相关的问题。当对一个可执行文件运行ldd时，它会告诉你程序使用的动态库和找到动态库的位置。但是如果你正在使用一个比较老 的glibc版本（2.2或更早），你可能会有一个有bug的ldd程序，它可能会报告在一个目录下发现一个动态库，但是真正运行程序时动态连接程序 （/lib/ld-linux.so.2）却可能到另外一个目录去找动态连接库。这通常因为/etc/ld.so.conf和 /etc/ld.so.cache文件不一致，或者/etc/ld.so.cache被破坏。在glibc 2.3.2版本上这个错误不会出现，可能ld-linux的这个bug已经被解决了。
尽管这样，ldd并不能把所有程序 依赖的动态库列出来，系统调用dlopen可以在需要的时候自动调入需要的动态库，而这些库可能不会被ldd列出来。作为glibc的一部分的NSS （Name Server Switch）库就是一个典型的例子，NSS的一个作用就是告诉应用程序到哪里去寻找系统帐号数据库。应用程序不会直接连接到NSS库，glibc则会通 过dlopen自动调入NSS库。如果这样的库偶然丢失，你不会被告知存在库依赖问题，但这样的程序就无法通过用户名解析得到用户ID了。让我们看一个例 子：
whoami程序会给出你自己的用户名，这个程序在一些需要知道运行程序的真正用户的脚本程序里面非常有用，whoami的一个示例输出如下： 
代码：
# whoami 
root
 
假设因为某种原因在升级glibc的过程中负责用户名和用户ID转换的库NSS丢失，我们可以通过把nss库改名来模拟这个环境： 
代码：
# mv /lib/libnss_files.so.2 /lib/libnss_files.so.2.backup 
# whoami 
whoami: cannot find username for UID 0
 
这里你可以看到，运行whoami时出现了错误，ldd程序的输出不会提供有用的帮助： 
代码：
# ldd /usr/bin/whoami 
libc.so.6 => /lib/libc.so.6 (0x4001f000) 
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
你只会看到whoami依赖Libc.so.6和ld-linux.so.2，它没有给出运行whoami所必须的其他库。这里时用strace跟踪whoami时的输出： 
代码：
strace -o whoami-strace.txt whoami
open("/lib/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory) 
open("/lib/i686/mmx/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory) 
stat64("/lib/i686/mmx", 0xbffff190) = -1 ENOENT (No such file or directory) 
open("/lib/i686/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory) 
stat64("/lib/i686", 0xbffff190) = -1 ENOENT (No such file or directory) 
open("/lib/mmx/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory) 
stat64("/lib/mmx", 0xbffff190) = -1 ENOENT (No such file or directory) 
open("/lib/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory) 
stat64("/lib", {st_mode=S_IFDIR|0755, st_size=2352, ...}) = 0 
open("/usr/lib/i686/mmx/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory) 
stat64("/usr/lib/i686/mmx", 0xbffff190) = -1 ENOENT (No such file or directory) 
open("/usr/lib/i686/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
 
你可以发现在不同目录下面查找libnss.so.2的尝试，但是都失败了。如果没有strace这样的工具，很难发现这个错误是由于缺少动态库造成的。现在只需要找到libnss.so.2并把它放回到正确的位置就可以了。











sudo -h
sudo -l
sudo -v
sudo -k
sudo -s
sudo -H
sudo [ -b ] [ -p prompt ] [ -u username/#uid] -s



配置文件 /etc/sudoers



分区 
	fdisk    MBR
	gdisk    GPT
	parted 
	
	
	ls -lsh 第一列为因为占块所占的大小 size为实际数据的大小

lsblk  查看分区








apt install build-essential
yum groupinstall DevelopmentTools        #若软件需要开发工具
yum groupinstall KernelSourceDevelopment #若软件需要图形接口
yum groupinstall "XSoftwareDevelopment"  #若按照的软件教旧







https://wiki.ubuntu.org.cn/%E9%A6%96%E9%A1%B5
https://wiki.ubuntu.org.cn/Qref/Apps
https://wiki.ubuntu.org.cn/UbuntuSkills







http://ddrv.cn/a/342647
https://www.jianshu.com/p/d7c9cef525bc


https://blog.csdn.net/yhc166188/category_7937752.html
https://blog.csdn.net/yhc166188/article/details/82795177


cleos wallet create [-n $walletName]  [--to-console | -f ~/$passwordFileName]  #会在~创建文件夹eos-wallet,默认的钱包名为default.wallet  
#cleos create key [--to-console | -f $keyFileName]  #产生public/private key 
#cleos wallet import -n $walletName --private-key $privKey
cleos wallet create_key -n $walletName 
cleos wallet list  #钱包名列表
#cleos wallet open -n $walletName
cleos wallet unlock -n $walletName --password $password
cleos wallet keys  #列举公钥
cleos wallet private-keys #列举私钥


#建立新账户12位字符 12345abcdefghijklmnopqrstuvwxyz
# 抵押0.001EOS用于网络，0.02EOS用于CPU，购买3k内存（约0.0465EOS）可满足新账户转账最低资源需求
cleos system newaccount --stake-net '0.001 EOS' --stake-cpu '0.02 EOS' --buy-ram-kbytes 3 <自动分配的账户名> <新注册账户名> <你的公钥>


##查看账户
#概要信息（可用资源、投票等）
cleos get account <账户名> 
cleos get table eosio  <账户名>  userres
# 查看账户抵押信息
cleos system listbw <账户名> 
cleos get table eosio <账户名>  delband
# 查看账户余额
cleos get currency balance eosio.token  <账户名> 
cleos get table eosio.token <账户名>  accounts


##转账
cleos transfer <转出账户名>  <转入账户名>  '0.0001 EOS' 'memo'

##竞拍短名（少于12字符的短账户名需竞拍，每24小时只成交一个。目前只能出价，主网激活14天后才正式交易）
# 查询短名出价情况
cleos system bidnameinfo  <短名> 
# 参与竞拍
cleos system bidname <本人账户名>  <短名>  '0.0001 EOS'


atop htop 
bash -c "echo a.sh | at now"

nmcli connection show
nmcli connection show eth0
nmcli connection modify eth0 \
connection.autoconnect yes \
ipv4.method manual \
ipv4.address $ip/$netmask \
ipv4.gateway $gateway \
ipv4.dns $dns
nmcli connection modify eth0 connection.autoconnect yes ipv4.method auto
nmcli connection up eth0

hostnamectl
hostnamectl set-hostname $hostname  #cat /etc/hostname

timedatectl
timedatectl list-timezone
timedatectl set-timezone  "Asia/Shanghai"
timedatectl set-time "2020-02-05 11:01"    # date && hwclock -w
timedatectl set-ntp 
ntpdate tock.stdtime.gov.tw && hwclock -w

localectl
localectl set-locale LANG=en-US.utf8



dmidecode -t [1|4|9|17]  #1SYS 4CPU 9PCI 17MEM

dd if=/dev/sda of=/dev/sdb #不必格式化，速度较慢
find / -print | cpio -covB > /dev/back &&  cpio -iduv < /dev/back
xfsdump 
xfsrestore
tar --exclude --exclude /proc -jcvp -f back.tar.bz2 /

tar --exclude --exclude /proc -N ‘2020-02-05’ -jcvp -f back.tar.bz2 /
rsync -av $src $dst

locate updatedb生效
man    mandb生效
tmpwatch 删除暂存文件

systemctl enabled/restart/status atd
at $time
>echo "hhh" > /dev/tty1  #at环境的默认输出都到/var/spool/mail PATH也会变，所以使用绝对路径
>sync                    #多指令
>sync
>shutdown -h now
>ctrl-d  #显示为EOT
时间格式$time
	HH:MM  04:00
	HH:MM YYYY-MM-DD 04:00 2020-02-20
	HH:MM[am|pm] [Month] [Date]  04pm July 30
	HH:MM[am|pm] + number [minutes|houres|days|weeks]  ex>now+5munutes
atq       #at -l  列出有哪些任务
at -c $jobNumber #列出job具体内容
atrm $jobNumber #at -d  删除任务job

batch 没时间限制的在CPU不忙的情况下执行 是一个shell脚本，本质上就是at


systemctl restart crond
cron  /var/spool/cron/$user文件中 日志在/var/log/cron
	-u  $user
	-e  #edit */5 3,6 3-6 
	-l  #list all items
	-r  #remove all items
minute hour day month week action

如何查找怪异进程：找crontab或怪异进程的父进程pid，然后kill -9 $ppid

help
help help 
help echo 
man man各帮助说明 man 7 hier文件系统目录说明   man runlevel  chkconfig是perl脚本
man bash
man test
man 3 readline查看快捷键绑定 

man -a signal 
man 7 signal       
kill -l
stty -a 

ctrl-c sigint 2
ctrl-z sigsup 
ctrl-s sigstop 19

ctrl-s 发送stop信号，未放弃fg控制权 ctrl-q 发送start信号
& ctrl-z 发送suspend信号 放弃前台控制权，放入后台 不接受输入，不能ctrl-c， 可以使用bg/fg
jobs -l # -表示最近最后倒数第二个 +表示最近最后一个 只能管理自身这个bash pid直接产生的后台进程， 间接产生的都管理不了
kill -9 %{$jobNumber} %{$jobNumer}   #eg kill -9 %1
fg %{$jobNumber}
bg %{jobNumber}  将前台进程由于ctrl-z状态为暂停变成后台进程运行，自动添加了一个&

ps axjf
top 
	-d $intervalSeconds  #默认3秒刷新一次
	-b -n $displayNumber > a.txt 
	-p $pid
    ?/h 显示按键帮助
	P CPU M Mem N PID T Time+ 排序默认CPU
pstree 
	-A  线
	-u  在括号中显示用户
	-p  在括号中显示pid
free -hw
fuser -v $file/$dir #eg .

systemctl 
	daemon-reload 
	disable 实质是删除链接
	mask    实质就是链接指空     ln -s /dev/null /etc/systemd/system/$service
	unmask  实质就是删除指空链接 rm /etc/systemd/system/$service
	
	
	show ssh #查看服务的配置文件
	/usr/lib/systemd/a.service/               #存放a服务的配置文件 
	/etc/systemd/system/a.service.d/a.conf
	/etc/systemd/system/a.service.d/wants/    #存放a服务启动后需要启动的服务脚本
	/etc/systemd/system/a.service.d/requires/ #存放a服务启动前需要启动的服务脚本
	
	get-default 
	set-default multi-user.target 
	isoloate graphical.target #切换到target  操作隔离等级使用isolate而不是start/stop
	poweroff #操作等级的快捷方式
	reboot
	suspend    #未关机 当唤醒时从内存中读取数据
	hibernate  #数据保存到硬盘然后关机， 当唤醒时从硬盘读取数据
	rescue     #root无法登录
	emergency  #允许root登录
	
	list-dependencies [$target]            #target默认为get-default获取， target中有哪些unit
	list-dependencies [$target] --reverse  #有哪些unit依赖这个target
	list-dependencies $service             #service依赖哪些unit
	list-dependencies $service --reverse  #有哪些unit依赖这个service

客户端命令行 man 1 logger
客户端API    man 3 syslog
服务端       rsyslog.service rsyslogd /etc/rsyslog.conf


/var/log/boot.log 本次启动
/var/log/dmesg

/var/log/lastlog 所有账号最近一次登录
/var/log/wtmp 正确登录
/var/log/faillog 错误登录
/var/log/secure  所有涉及账号密码登录 包括系统的login程序 图形接口登录gdm程序 su sudo ssh telnet

/var/log/messages 
/var/log/cron

logger -p $serviceName.$loglevel "$msg"
logrotate -vf /etc/logrotate.conf  #-v尝试进行一次详细的lograte  -f强制进行一次logrotate
journalctl [-nrpf] [--since TIME] [--until TIME] _optional
	-n 5   #最近几条 类似于head -n 5
	-r     #反向输出 类似于ls -rt 
	-p err #优先级
	-f     #类似于tail -f 
	TIME   #today tomorrow "2020-02-05 12:00:00"
	_SYSTEMD_UNIT=a.service #只显示a.service 
	_COMM=bash              #只显示与命令有关的
	_PID=pid                #只显示pid有关的
	SYSLOG_FACILITY=[0-23]  #使用syslog.h中的服务序号
logwatch 是一分析syslog的工具  是一perl脚本
mail     #读取邮件发送邮件 mail -s ”$subject" $user < $mail_content.txt

dmidecode -t $type
	1  #SYS
	4  #CPU
	9  #主版插槽
	17 #MEM
lspci [-v|-vv] #列出pci接口
lsusb [-t]#以tree形式列出usb
smartctl -t short /dev/sda  #检测磁盘坏道和寿命 t short for test /dev/sda物理磁盘名
smartctl -a       /dev/sda  #a short for all display all info  self-monitoring analysis and report technology system 


tar.gz == tgz
tar.bz2       #(bzip2)
xz

#patch因为不是源码的全部，而是diff出来的， 所以体积小 便于下载存储
patch -p$number < a.patch #给源码打补丁即diff文件 然后重新make && make install
#ldconfig 预先加载so到内存中以便加速访问
echo "/usr/lib/mmysqlclid" >> /etc/ld.so.conf.d/mmysql.conf #配置哪些so需要预先加载
ldconfig [-f /etc/ld.so.conf] [-C /etc/ld.so.cache]  #加载配置文件中定义
ldconfig -p #打印已加载的so
ldd [-v|-d|-r] $exe | $lib.so  #load dependency
	-v #列出所有内容信息
	-d #重新将有丢失的link点show出来
	-r #显示将elf有关的错误
pldd $pid #正在运行的程序      #process load dependencies

tmux  ctrl-b q  #显示pane数字
             x  #kill pane
			 m  #mark current pane 加粗
			 o  #select next pane
			 ;  #last pane
			 
			 c  #create window
			 &  #kill current window
			 p  #pre window
			 n  #next window
			 l  #last windows 
			 '  #输入windows index
			 w  #choose window
			 0-9 #choose window


