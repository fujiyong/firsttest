\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{xeCJK}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother


\date{}

\begin{document}

\section{Python 速查表中文版}\label{header-n0}

\begin{itemize}
\item
  本手册是 \href{http://datasciencefree.com/python.pdf}{Python cheat
  sheet} 的中文翻译版。原作者：Arianne Colton and Sean
  Chen(\href{mailto:data.scientist.info@gmail.com}{\nolinkurl{data.scientist.info@gmail.com}})
\item
  编译：\href{https://github.com/ucasFL}{ucasFL}
\end{itemize}

\protect\hyperlink{header-n32}{惯例}

\protect\hyperlink{header-n43}{获取帮助}

\protect\hyperlink{header-n54}{模块}

\protect\hyperlink{header-n69}{数值类类型}

\protect\hyperlink{header-n128}{数据结构}

\protect\hyperlink{header-n217}{函数}

\protect\hyperlink{header-n307}{控制流}

\protect\hyperlink{header-n332}{面向对象编程}

\protect\hyperlink{header-n354}{常见字符串操作}

\protect\hyperlink{header-n357}{异常处理}

\protect\hyperlink{header-n369}{对列表、字典和元组的深入理解}

\hypertarget{header-n32}{\subsection{惯例}\label{header-n32}}

\begin{itemize}
\item
  Python 对大小写敏感；
\item
  Python 的索引从 0 开始（所有编程语言均如此）；
\item
  Python 使用空白符（制表符或空格）来缩进代码，而不是使用花括号。
\end{itemize}

\hypertarget{header-n43}{\subsection{获取帮助}\label{header-n43}}

\begin{itemize}
\item
  获取主页帮助： \texttt{help()}
\item
  获取函数帮助： \texttt{help(str.replace)}
\item
  获取模块帮助： \texttt{help(re)}
\end{itemize}

\hypertarget{header-n54}{\subsection{模块}\label{header-n54}}

模块亦称库，它只是一个简单地以 \texttt{.py} 为后缀的文件。

\begin{itemize}
\item
  列出模块内容：\texttt{dir(module1)}
\item
  导入模块：\texttt{import\ module}
\item
  调用模块中的函数：\texttt{module1.func1()}
\end{itemize}

\textbf{注：\texttt{import}
语句会创建一个新的名字空间，并且在该名字空间内执行 \texttt{.py}
文件中的所有语句。如果你想把模块内容导入到当前名字空间，请使用
\texttt{from\ module1\ import\ *} 语句。}

\hypertarget{header-n69}{\subsection{数值类类型}\label{header-n69}}

查看变量的数据类型：\texttt{type(variable)}

\subsubsection{六种经常使用的数据类型}\label{header-n72}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{int/long}：过大的 \texttt{int} 类型会被自动转化为
  \texttt{long} 类型。
\item
  \textbf{float}：64 位，Python 中没有 \texttt{double} 类型。
\item
  \textbf{bool}：真或假。
\item
  \textbf{str}：在 Python 2 中默认以 ASCII 编码，而在 Python 3 中默认以
  Unicode 编码；

  \begin{itemize}
  \item
    字符串可置于单/双/三引号中；
  \item
    字符串是字符的序列，因此可以像处理其他序列一样处理字符串；
  \item
    特殊字符可通过 \texttt{\textbackslash{}} 或者前缀 \texttt{r} 实现：
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{str1 }\OperatorTok{=} \VerbatimStringTok{r'this\textbackslash{}f?ff'}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \item
    字符串可通过多种方式格式化：
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{template }\OperatorTok{=} \StringTok{'}\SpecialCharTok{%.2f}\StringTok{ }\SpecialCharTok{%s}\StringTok{ haha $}\SpecialCharTok{%d}\StringTok{'}\OperatorTok{;}
\NormalTok{str1 }\OperatorTok{=}\NormalTok{ template }\OperatorTok{%}\NormalTok{ (}\FloatTok{4.88}\NormalTok{, }\StringTok{'hola'}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{NoneType(None)}：Python \texttt{null} 值（只有 None
  对象的一个实例中存在）。

  \begin{itemize}
  \item
    \texttt{None} 不是一个保留关键字，而是 \textbf{NoneType}
    的一个唯一实例。
  \item
    \texttt{None} 通常是可选函数参数的默认值：
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ func1(a, b, c }\OperatorTok{=} \VariableTok{None}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \item
    \texttt{None} 的常见用法：
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ variable }\KeywordTok{is} \VariableTok{None}\NormalTok{ :}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{datetime}：Python 内建的 datetime 模块提供了
  \texttt{datetime}、\texttt{data} 以及 \texttt{time} 类型。

  \begin{itemize}
  \item
    \texttt{datetime} 组合了存储于 \texttt{date} 和 \texttt{time}
    中的信息。
  \end{itemize}
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#从字符串中创建 datetime}
\NormalTok{dt1 }\OperatorTok{=}\NormalTok{ datetime.strptime(}\StringTok{'20091031'}\NormalTok{, }\StringTok{'%Y%m}\SpecialCharTok{%d}\StringTok{'}\NormalTok{)}
\CommentTok{#获取 date 对象}
\NormalTok{dt1.date()}
\CommentTok{#获取 time 对象}
\NormalTok{dt1.time()}
\CommentTok{#将 datetime 格式化为字符串}
\NormalTok{dt1.strftime(}\StringTok{'%m/}\SpecialCharTok{%d}\StringTok{/%Y%H:%M'}\NormalTok{)}
\CommentTok{#更改字段值}
\NormalTok{dt2 }\OperatorTok{=}\NormalTok{ dt1.replace(minute }\OperatorTok{=} \DecValTok{0}\NormalTok{, second }\OperatorTok{=} \DecValTok{30}\NormalTok{)}
\CommentTok{#做差, diff 是一个 datetime.timedelta 对象}
\NormalTok{diff }\OperatorTok{=}\NormalTok{ dt1 }\OperatorTok{-}\NormalTok{ dt2}
\end{Highlighting}
\end{Shaded}

\textbf{注：Python 中的绝大多数对象都是可变的，只有字符串和元组例外。}

\hypertarget{header-n128}{\subsection{数据结构}\label{header-n128}}

\textbf{注：所有的 non-Get 函数调用，比如下面例子中的
\texttt{list1.sort()} 都是原地操作，即不会创建新的对象，除非特别声明。}

\subsubsection{元组}\label{header-n131}

元组是 Python 中任何类型的对象的一个一维、固定长度、不可变的序列。

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#创建元组}
\NormalTok{tup1 }\OperatorTok{=} \DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6} 
\CommentTok{# or}
\NormalTok{tup1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{)}
\CommentTok{#创建嵌套元组}
\NormalTok{tup1 }\OperatorTok{=}\NormalTok{ (}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{), (}\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{)}
\CommentTok{#将序列或迭代器转化为元组}
\BuiltInTok{tuple}\NormalTok{([}\DecValTok{1}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{])}
\CommentTok{#连接元组}
\NormalTok{tup1 }\OperatorTok{+}\NormalTok{ tup2}
\CommentTok{#解包元组}
\NormalTok{a, b, c }\OperatorTok{=}\NormalTok{ tup1}
\end{Highlighting}
\end{Shaded}

元组应用：

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#交换两个变量的值}
\NormalTok{a, b }\OperatorTok{=}\NormalTok{ b, a}
\end{Highlighting}
\end{Shaded}

\subsubsection{列表}\label{header-n138}

列表是 Python
中任何类型的对象的一个一维、非固定长度、可变（比如内容可以被修改）的序列。

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#创建列表}
\NormalTok{list1 }\OperatorTok{=}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\StringTok{'a'}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\CommentTok{#or}
\NormalTok{list1 }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(tup1)}
\CommentTok{#连接列表}
\NormalTok{list1 }\OperatorTok{+}\NormalTok{ list2 }
\CommentTok{#or}
\NormalTok{list1.extend(list2)}
\CommentTok{#追加到列表的末尾}
\NormalTok{list1.append(}\StringTok{'b'}\NormalTok{)}
\CommentTok{#插入指定位置}
\NormalTok{list1.insert(PosIndex, }\StringTok{'a'}\NormalTok{)}
\CommentTok{#反向插入，即弹出给定位置的值/删除}
\NormalTok{ValueAtIdx }\OperatorTok{=}\NormalTok{ list1.pop(PosIndex)}
\CommentTok{#移除列表中的第一个值, a 必须是列表中第一个值}
\NormalTok{list1.remove(}\StringTok{'a'}\NormalTok{)}
\CommentTok{#检查成员资格}
\DecValTok{3} \KeywordTok{in}\NormalTok{ list1 }\OperatorTok{=>} \VariableTok{True} \KeywordTok{or} \VariableTok{False}
\CommentTok{#对列表进行排序}
\NormalTok{list1.sort()}
\CommentTok{#按特定方式排序}
\NormalTok{list1.sort(key }\OperatorTok{=} \BuiltInTok{len}\NormalTok{) }\CommentTok{# 按长度排序}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  使用 +
  连接列表会有比较大的开支，因为这个过程中会创建一个新的列表，然后复制对象。因此，使用
  \texttt{extend()} 是更明智的选择；
\item
  \texttt{insert} 和 \texttt{append} 相比会有更大的开支（时间/空间）；
\item
  在列表中检查是否包含一个值会比在字典和集合中慢很多，因为前者需要进行线性扫描，而后者是基于哈希表的，所以只需要花费常数时间。
\end{itemize}

\paragraph{\texorpdfstring{内建的 \texttt{bisect}
模块}{内建的 bisect 模块}}\label{header-n152}

\begin{itemize}
\item
  对一个排序好的列表进行二分查找或插入；
\item
  \texttt{bisect.bisect}找到元素在列表中的位置，\texttt{bisect.insort}将元素插入到相应位置。用法：
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ bisect}
\NormalTok{list1 }\OperatorTok{=} \BuiltInTok{list}\NormalTok{(}\BuiltInTok{range}\NormalTok{(}\DecValTok{10}\NormalTok{))}
\CommentTok{#找到 5 在 list1 中的位置，从 1 开始，因此 position = index + 1}
\NormalTok{bisect.bisect(list1, }\DecValTok{5}\NormalTok{)}
\CommentTok{#将 3.5 插入 list1 中合适位置}
\NormalTok{bisect.insort(list1, }\FloatTok{3.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{注：\texttt{bisect}
模块中的函数并不会去检查列表是否排序好，因为这会花费很多时间。所以，对未排序好的列表使用这些函数也不会报错，但可能会返回不正确的结果。}

\subsubsection{针对序列类型的切片}\label{header-n163}

序列类型包括 \texttt{str}、\texttt{array}、\texttt{tuple}、\texttt{list}
等。

用法：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list1[start:stop]}
\CommentTok{#如果使用 step}
\NormalTok{list1(start:stop:step)}
\end{Highlighting}
\end{Shaded}

\textbf{注：切片结果包含 \texttt{start} 索引，但不包含 \texttt{stop}
索引；\texttt{start/stop}
索引可以省略，如果省略，则默认为序列从开始到结束，如
\texttt{list1\ ==\ list1{[}:{]}} 。}

\texttt{step} 的应用：

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#取出奇数位置的元素}
\NormalTok{list1[::}\DecValTok{2}\NormalTok{]}
\CommentTok{#反转字符串}
\NormalTok{str1[::}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\subsubsection{字典（哈希映射）}\label{header-n174}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#创建字典}
\NormalTok{dict1 }\OperatorTok{=}\NormalTok{ \{}\StringTok{'key1'}\NormalTok{: }\StringTok{'value1'}\NormalTok{, }\DecValTok{2}\NormalTok{: [}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{]\}}
\CommentTok{#从序列创建字典}
\BuiltInTok{dict}\NormalTok{(}\BuiltInTok{zip}\NormalTok{(KeyList, ValueList))}
\CommentTok{#获取/设置/插入元素}
\NormalTok{dict1[}\StringTok{'key1'}\NormalTok{]}
\NormalTok{dict1[}\StringTok{'key1'}\NormalTok{] }\OperatorTok{=} \StringTok{'NewValue'}
\CommentTok{#get 提供默认值}
\NormalTok{dict1.get(}\StringTok{'key1'}\NormalTok{, DefaultValue)}
\CommentTok{#检查键是否存在}
\CommentTok{'key1'} \KeywordTok{in}\NormalTok{ dict1}
\CommentTok{#获取键列表}
\NormalTok{dict1.keys()}
\CommentTok{#获取值列表}
\NormalTok{dict1.values()}
\CommentTok{#更新值}
\NormalTok{dict1.update(dict2)}\CommentTok{#dict1 的值被 dict2 替换}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  如果键不存在，则会出现 \texttt{KeyError\ Exception} 。
\item
  当键不存在时，如果 \texttt{get()}不提供默认值则会返回 \texttt{None} 。
\item
  以相同的顺序返回键列表和值列表，但顺序不是特定的，又称极大可能非排序。
\end{itemize}

\paragraph{有效字典键类型}\label{header-n186}

\begin{itemize}
\item
  键必须是不可变的，比如标量类型(\texttt{int}、\texttt{float}、\texttt{string})或者元组（元组中的所有对象也必须是不可变的）。
\item
  这儿涉及的技术术语是 \texttt{hashability}。可以用函数
  \texttt{hash()}来检查一个对象是否是可哈希的，比如
  \texttt{hash(\textquotesingle{}This\ is\ a\ string\textquotesingle{})}
  会返回一个哈希值，而 \texttt{hash({[}1,2{]})} 则会报错（不可哈希）。
\end{itemize}

\subsubsection{集合}\label{header-n194}

\begin{itemize}
\item
  一个集合是一些无序且唯一的元素的聚集；
\item
  你可以把它看成只有键的字典；
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#创建集合}
\BuiltInTok{set}\NormalTok{([}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{])}
\CommentTok{#or}
\NormalTok{\{}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{3}\NormalTok{\}}
\CommentTok{#子集测试}
\NormalTok{set1.issubset(set2)}
\CommentTok{#超集测试}
\NormalTok{set1.issuperset(set2)}
\CommentTok{#测试两个集合中的元素是否完全相同}
\NormalTok{set1 }\OperatorTok{==}\NormalTok{ set2}
\end{Highlighting}
\end{Shaded}

\paragraph{集合操作}\label{header-n203}

\begin{itemize}
\item
  并（又称或）：\texttt{set1\ \textbar{}\ set2}
\item
  交（又称与）：\texttt{set1\ \&\ set2}
\item
  差：\texttt{set1\ -\ set2}
\item
  对称差（又称异或）：\texttt{set1\ \^{}\ set2}
\end{itemize}

\hypertarget{header-n217}{\subsection{函数}\label{header-n217}}

Python 的函数参数传递是通过\textbf{引用传递}。

\begin{itemize}
\item
  基本形式
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ func1(posArg1, keywordArg1 }\OperatorTok{=} \DecValTok{1}\NormalTok{, ..)}
\end{Highlighting}
\end{Shaded}

\textbf{注}

\begin{itemize}
\item
  关键字参数必须跟在位置参数的后面；
\item
  默认情况下，Python 不会``延迟求值''，表达式的值会立刻求出来。
\end{itemize}

\subsubsection{函数调用机制}\label{header-n234}

\begin{itemize}
\item
  所有函数均位于模块内部作用域。见``模块''部分。
\item
  在调用函数时，参数被打包成一个元组和一个字典，函数接收一个元组
  \texttt{args} 和一个字典 \texttt{kwargs}，然后在函数内部解包。
\end{itemize}

``函数是对象''的常见用法：

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ func1(ops }\OperatorTok{=}\NormalTok{ [}\BuiltInTok{str}\NormalTok{.strip, user_define_func, ..], ..):}
  \ControlFlowTok{for}\NormalTok{ function }\KeywordTok{in}\NormalTok{ ops:}
\NormalTok{    value }\OperatorTok{=}\NormalTok{ function(value)}
\end{Highlighting}
\end{Shaded}

\subsubsection{返回值}\label{header-n245}

\begin{itemize}
\item
  如果函数末尾没有 \texttt{return} 语句，则不会返回任何东西。
\item
  如果有多个返回值则通过一个元组来实现。
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{return}\NormalTok{ (value1, value2)}
\NormalTok{value1, value2 }\OperatorTok{=}\NormalTok{ func1(..)}
\end{Highlighting}
\end{Shaded}

\subsubsection{匿名函数（又称 LAMBDA 函数）}\label{header-n254}

\begin{itemize}
\item
  什么是匿名函数？
\end{itemize}

匿名函数是一个只包含一条语句的简单函数。

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lambda}\NormalTok{ x : x }\OperatorTok{*} \DecValTok{2}
\CommentTok{#def func1(x) : return x * 2}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  匿名函数的应用：'curring'，又称利用已存在函数的部分参数来派生新的函数。
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ma60 }\OperatorTok{=} \KeywordTok{lambda}\NormalTok{ x : pd.rolling_mean(x, }\DecValTok{60}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsubsection{一些有用的函数（针对数据结构）}\label{header-n267}

\begin{itemize}
\item
  \texttt{enumerate()} 返回一个序列\texttt{(i,\ value)}元组，\texttt{i}
  是当前 \texttt{item} 的索引。
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ i, value }\KeywordTok{in} \BuiltInTok{enumerate}\NormalTok{(collection):}
\end{Highlighting}
\end{Shaded}

应用：创建一个序列中值与其在序列中的位置的字典映射（假设每一个值都是唯一的）。

\begin{itemize}
\item
  \texttt{sort()}可以从任意序列中返回一个排序好的序列。
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{sorted}\NormalTok{([}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{]) }\OperatorTok{=>}\NormalTok{ [}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

应用：

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{sorted}\NormalTok{(}\BuiltInTok{set}\NormalTok{(}\StringTok{'abc bcd'}\NormalTok{)) }\OperatorTok{=>}\NormalTok{ [}\StringTok{' '}\NormalTok{,}
\StringTok{'a'}\NormalTok{, }\StringTok{'b'}\NormalTok{, }\StringTok{'c'}\NormalTok{, }\StringTok{'d'}\NormalTok{]}
\CommentTok{# 返回一个字符串排序后无重复的字母序列}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \texttt{zip()}函数可以把许多列表、元组或其他序列的元素配对起来创建一系列的元组。
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{zip}\NormalTok{(seq1, seq2) }\OperatorTok{=>}\NormalTok{ [(}\StringTok{'seq1_1'}\NormalTok{, }\StringTok{'seq2_1'}\NormalTok{), (..), ..]}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{zip()}可以接收任意数量的序列作为参数，但是产生的元素的数目取决于最短的序列。
\end{enumerate}

应用：多个序列同时迭代：

\begin{verbatim}
for i, (a, b) in enumerate(zip(seq1, seq2)):
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{unzip}：另一种思考方式是把一些行转化为一些列：
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{seq1, seq2 }\OperatorTok{=} \BuiltInTok{zip}\NormalTok{(zipOutput)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \texttt{reversed()} 将一个序列的元素以逆序迭代。
\end{itemize}

\begin{verbatim}
list(reversed(range(10))) 
\end{verbatim}

\textbf{\texttt{reversed()} 会返回一个迭代器，\texttt{list()}
使之成为一个列表。}

\hypertarget{header-n307}{\subsection{控制流}\label{header-n307}}

\begin{itemize}
\item
  用于 \texttt{if-else} 条件中的操作符：
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#检查两个变量是否是相同的对象}
\NormalTok{var1 }\KeywordTok{is}\NormalTok{ var2}
\CommentTok{#检查两个变量是否是不同的对象}
\NormalTok{var1 }\KeywordTok{is} \KeywordTok{not}\NormalTok{ var2}
\CommentTok{#检查两个变量的值是否相等}
\NormalTok{var1 }\OperatorTok{==}\NormalTok{ var2}
\end{Highlighting}
\end{Shaded}

\textbf{注：Python 中使用 \texttt{and}、\texttt{or}、\texttt{not}
来组合条件，而不是使用
\texttt{\&\&}、\texttt{\textbar{}\textbar{}}、\texttt{!} 。}

\begin{itemize}
\item
  \texttt{for}循环的常见用法：
\end{itemize}

\begin{verbatim}
#可迭代对象（list、tuple）或迭代器
for element in iterator:
#如果元素是可以解包的序列
for a, b, c in iterator:
\end{verbatim}

\begin{itemize}
\item
  \texttt{pass}：无操作语句，在不需要进行任何操作的块中使用。
\item
  三元表达式，又称简洁的 \texttt{if-else}，基本形式：
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{value }\OperatorTok{=}\NormalTok{ true}\OperatorTok{-}\NormalTok{expr }\ControlFlowTok{if}\NormalTok{ condition }\ControlFlowTok{else}\NormalTok{ false}\OperatorTok{-}\NormalTok{expr}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  Python 中没有 \texttt{switch/case} 语句，请使用 \texttt{if/elif}。
\end{itemize}

\hypertarget{header-n332}{\subsection{面向对象编程}\label{header-n332}}

\begin{itemize}
\item
  \textbf{对象}是 Python 中所有类型的根。
\item
  万物（数字、字符串、函数、类、模块等）皆为对象，每个对象均有一个类型（type）。对象变量是一个指向变量在内存中位置的指针。
\item
  所有对象均为\textbf{引用计数}。
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sys.getrefcount(}\DecValTok{5}\NormalTok{) }\OperatorTok{=>}\NormalTok{ x}
\NormalTok{a }\OperatorTok{=} \DecValTok{5}\NormalTok{, b }\OperatorTok{=}\NormalTok{ a}
\CommentTok{#上式会在等号的右边创建一个对象的引用，因此 a 和 b 均指向 5}
\NormalTok{sys.getrefcount(}\DecValTok{5}\NormalTok{)}
\OperatorTok{=>}\NormalTok{ x }\OperatorTok{+} \DecValTok{2}
\KeywordTok{del}\NormalTok{(a)}\OperatorTok{;}\NormalTok{ sys.getrefcount(}\DecValTok{5}\NormalTok{) }\OperatorTok{=>}\NormalTok{ x }\OperatorTok{+} \DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  类的基本形式：
\end{itemize}

\begin{verbatim}
class MyObject(object):
  # 'self' 等价于 Java/C++ 中的 'this'
  def __init__(self, name):
    self.name = name
  def memberFunc1(self, arg1):
      ..
  @staticmethod
  def classFunc2(arg1):
    ..
obj1 = MyObject('name1')
obj1.memberFunc1('a')
MyObject.classFunc2('b')
\end{verbatim}

\begin{itemize}
\item
  有用的交互式工具：
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{dir}\NormalTok{(variable1) }\CommentTok{#列出对象的所有可用方法}
\end{Highlighting}
\end{Shaded}

\hypertarget{header-n354}{\subsection{常见字符串操作}\label{header-n354}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#通过分隔符连接列表/元组}
\CommentTok{', '}\NormalTok{.join([ }\StringTok{'v1'}\NormalTok{, }\StringTok{'v2'}\NormalTok{, }\StringTok{'v3'}\NormalTok{]) }\OperatorTok{=>} \StringTok{'v1, v2, v3'}

\CommentTok{#格式化字符串}
\NormalTok{string1 }\OperatorTok{=} \StringTok{'My name is }\SpecialCharTok{\{0\}}\StringTok{　}\SpecialCharTok{\{name\}}\StringTok{'}
\NormalTok{newString1 }\OperatorTok{=}\NormalTok{ string1.}\BuiltInTok{format}\NormalTok{(}\StringTok{'Sean'}\NormalTok{, name }\OperatorTok{=}　\StringTok{'Chen'}\NormalTok{)}

\CommentTok{#分裂字符串}
\NormalTok{sep }\OperatorTok{=} \StringTok{'-'}\OperatorTok{;}
\NormalTok{stringList1 }\OperatorTok{=}\NormalTok{　string1.split(sep)}

\CommentTok{#获取子串}
\NormalTok{start }\OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{string1[start:}\DecValTok{8}\NormalTok{]}

\CommentTok{#补 '0' 向右对齐字符串}
\NormalTok{month }\OperatorTok{=} \StringTok{'5'}\OperatorTok{;}
\NormalTok{month.zfill(}\DecValTok{2}\NormalTok{) }\OperatorTok{=>} \StringTok{'05'}
\NormalTok{month }\OperatorTok{=} \StringTok{'12'}\OperatorTok{;}
\NormalTok{month.zfill(}\DecValTok{2}\NormalTok{) }\OperatorTok{=>} \StringTok{'12'}
\NormalTok{month.zfill(}\DecValTok{3}\NormalTok{) }\OperatorTok{=>} \StringTok{'012'}
\end{Highlighting}
\end{Shaded}

对列表和字典以及元组的深入理解

\hypertarget{header-n357}{\subsection{异常处理}\label{header-n357}}

\begin{itemize}
\item
  基本形式：
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{try}\NormalTok{:}
\NormalTok{  ..}
\ControlFlowTok{except} \PreprocessorTok{ValueError} \ImportTok{as}\NormalTok{ e:}
  \BuiltInTok{print}\NormalTok{ e}
\ControlFlowTok{except}\NormalTok{ (}\PreprocessorTok{TypeError}\NormalTok{, AnotherError):}
\NormalTok{  ..}
\ControlFlowTok{except}\NormalTok{:}
\NormalTok{  ..}
\ControlFlowTok{finally}\NormalTok{:}
\NormalTok{  .. }\CommentTok{# 清理，比如 close db;}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  手动引发异常：
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{raise} \PreprocessorTok{AssertionError} \CommentTok{# 断言失败}
\ControlFlowTok{raise} \PreprocessorTok{SystemExit}
\CommentTok{# 请求程序退出}
\ControlFlowTok{raise} \PreprocessorTok{RuntimeError}\NormalTok{(}\StringTok{'错误信息 :..'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{header-n369}{\subsection{对列表和字典以及元组的深入理解}\label{header-n369}}

语法糖（syntactic sugar）会使代码变得更加易读易写。

\subsubsection{对列表的理解}\label{header-n372}

将一些元素通过一个简短的语句传入一个过滤器进行过滤和转化，然后可以组成一个新的列表。

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#基本形式}
\NormalTok{[expr }\ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ collection }\ControlFlowTok{if}\NormalTok{ condition]}
\CommentTok{#ShortCut}
\NormalTok{result }\OperatorTok{=}\NormalTok{ []}
\ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ collection:}
  \ControlFlowTok{if}\NormalTok{ condition:}
\NormalTok{    result.append(expr)}
\end{Highlighting}
\end{Shaded}

可以省略过滤条件，只留下表达式。

\subsubsection{对字典的理解}\label{header-n378}

基本形式：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{key}\OperatorTok{-}\NormalTok{expr : value}\OperatorTok{-}\NormalTok{expr }\ControlFlowTok{for}\NormalTok{ value }\KeywordTok{in}\NormalTok{ collection }\ControlFlowTok{if}\NormalTok{ condition\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{对集合的理解}\label{header-n382}

基本形式：和列表一样，只是应该使用 \texttt{()} 而不是 \texttt{{[}{]}} 。

\subsubsection{嵌套列表}\label{header-n385}

基本形式：

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[expr }\ControlFlowTok{for}\NormalTok{ val }\KeywordTok{in}\NormalTok{ collection }\ControlFlowTok{for}\NormalTok{ innerVal }\KeywordTok{in}\NormalTok{ val }\ControlFlowTok{if}\NormalTok{ condition]}
\end{Highlighting}
\end{Shaded}

\end{document}
