定位
	1取代基于ip位置寻址的http web可能单点故障且可被isp篡改的服务器,而使用基于内容寻址的方式的永不离线的ipfs
	2成本提供存储, 所以需要支付FileCoin
	3相对于单节点存储,分布存储,下载效率更高;可以避免更多更大的DDOS攻击,安全性更高


Android
	安装软件 sshdroid  #参考https://blog.csdn.net/zhanghuoding/article/details/72848307
			可以得知 root@:2222
	登录    ssh -p 2222 root@192.168.1.152 提示默认密码是admin

	ps:  android termial #可以在手机上直接安装这个软件,就有termial client了,有hacker的感觉了
各平台编译
	android    make build CGO_ENABLED=0 GOOS=linux  GOARCH=arm
	centos     make build CGO_ENABLED=0 GOOS=linux  GOARCH=386   #GOARCH=amd64  make install
	mac        make build CGO_ENABLED=1 GOOS=darwin GOARCH=amd64
	windows    make build               GOOS=windows GOARCH=amd64
	


使用
	帮助
		ipfs --help
		ipfs commands
		ipfs $cmd help

	环境变量
		默认数据文件夹是~/.ipfs,通过环境变量IPFS_PATH修改

	初始化	
		ipfs init
	配置
		允许跨域访问   ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["*"]'
					  ipfs config --json API.HTTPHeaders.Access-Control-Allow-Credentials '["true"]'
					  ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods '["PUT", "GET", "POST", "OPTIONS"]'
		允许api监听    ipfs config --json Addresses.API '"/ip4/0.0.0.0/tcp/5001"'              #默认只能通过127.0.0.1:5001本机访问
		配置网关监听   ipfs config --json Addresses.Gateway '"/ip4/0.0.0.0/tcp/8080"'          #默认只能通过127.0.0.1:8080本机访问
	启动
		ipfs daemon
	管理界面 查看系统状态 管理文件 配置系统
		http://192.168.1.152:5001/webui
	网关(ReadOnly)
		个人 https://localhost:8080/ipfs/$hash
		官方 https://ipfs.io/ipfs/$hash
		理想 ipfs://$hash

	操作
		添加 add --pin true 默认pin住 -s size-256k 默认块的大小为256K
			ipfs add    $filename       #返回的是用私钥签名的hash值只是文件内容的hash值,而没有文件名的信息  其实这里的hash用key更准确 key使用SFS的multi-format中的multi-hash表示
			                            # key = 1个字节的hash类型 + 1 个字节的hash值长度 + digest(hash(content),private_key) 是hash(content)的摘要,不是hash  
										#  访问内容的时候使用hash($digest) =? hash(content)这样的步骤进行验证
			ipfs add -r $dirname
			ipfs add -r .

			Wrapped形式   //总结 ls操作对象只能是目录  cat的对象只能是文件
				ipfs add -w $filename              #--wrap-with-directory 返回2个hash值 第一个是文件内容的hash值 第二个是文件名和文件所处的路径信息的hash值
				                                   #多hash指纹的多级路径访问机制
												   #	/ipfs/<hash-of-bar>/bar/baz
												   #    /ipfs/<hash-of-bar>/baz
												   #    /ipfs/<hash-of-baz>
				ipfs ls -v  $dir_hash2             #返回文件内容的hash1 文件size 文件名
				ipfs cat    $dir_hash2/$file_name  #不能 ipfs cat $dir_hash
				ipfs cat    $file_hash

			当文件大于size256K时,文件被切割成Block,这时可以通过查看根节点hash获取文件切割的小block hash
				ipfs object stat  $big_size_file_root_hash
				ipfs object links $big_size_file_root_hash

		查看
			本地节点
				ipfs cat /ipfs/$hash    #不用管原来的目录结构
				等价于 http://127.0.0.1:8080/ipfs/$hash
			全网节点
				https://ipfs.io/ipfs/$hash #若有内容,则上传至全网
			绑定ipns 解决文件更新问题, add a.txt && publish hash(a.txt) 以后a.txt内容变更也可以使用以前的hash(a.txt)
				绑定根节点     ipfs name publish --key=self $raw_dir_root_name_hash #绑定跟节点,以后访问都可以根据跟节点的相对路径访问 默认使用selfKey  #如果网站重新部署,需要重新publish
				根据跟节点访问 ipfs cat /ipfs/$raw_dir_root_name_hash/$raw_dir_second_level_name/$file_name
				              ipfs cat /ipns/`ipfs id`/$raw_dir_second_level_name/$file_name
				# publish之后就可以查看根上传的根目录的hash与ipfs id的对应关系
				ipfs name resolve `ipfs id`  #返回根目录的hash值对应的哪个publish操作时的hash值  ipns->ipfs之间的映射
			dns 使用域名来代替ipns的peer hashID, 解决了需要记忆跟节点hash的问题
				ipfs cat /ipfs/ipfs.$raw_dir_root_name.org/$raw_dir_name/$file_name   //使用域名系统dns,保留原来的目录结构 
			                                                                      	  //dns系统需要添加一条记录txt记录
			                                                                          //   记录类型 txt
			                                                                          //   主机记录 ipfs
			                                                                          //   记录值   dnslink=/ipns/$node_id
																					  //   ipfs.benet.ai TXT "ipfs=xxxx"  等价于 ln -s /ipns/xxxx /ipns/benet.ai
			                                                                          //原来的目录结构是raw_dir_root_name/raw_dir2_name/file_name
		拉取
			ipfs get /ipfs/$hash   #使用公钥验证该hash是否有效
			等价于 http://127.0.0.1:8080/ipfs/$hash

	缓存
		为了快速提供本地服务,需提供缓存cache服务
		为了控制缓存的大小,执行ipfs repo gc需要从cache剔除掉一些一段时间内没使用的
		为防止一些需要的文件被剔除,需要使用pin命令固定在cache
		通过add添加的文件默认就是pin过的
		文件本地持久化 ipfs pin ls        #查看哪些文件是在本地的,没有从远程服务器下载下载.pin将长期保留在本地,而不会被垃圾回收
                      ipfs pin ls --type=all $hash  #查看$hash对应的文件时候被pin
                      ipfs pin add $hash      #一般添加其他ipfs节点的根目录hash值, 这样就将remote host的文件系统同步到本地 以便加速访问
                      ipfs pin rm $hash    #文件的hash  删除文件的pin状态
                      ipfs pin rm -r $hash #目录的hash  删除目录的pin状态


	查看
		id            ipfs id       #实际就是hash(rsa.publicKey)
        配置参数含义   ipfs help init

        其他节点       ipfs swarm peers
					  ipfs swarm addrs
					  ipfs swarm connect /ipv4/$config中peer表示法

    修改配置.ipfs/config,再reboot
    	先修后改
    		导出原来配置     ipfs config show > ipfs.conf.json
    		导入修改后的配置 ipfs config replace ipfs.conf.json
    	直接修改
    		ipfs config edit

    当管理多个网站时,产生公钥
    	ipfs key list -l //默认有个名为self值为节点id的key
    	ipfs key gen --type=rsa --size=2048 mykey  #创建一个名为mykey的新key
    	ipfs add a.txt 
    	ipfs name publish --key=mykey $hash



编码
	$cat tos.go
	package main

	import (
		"log"
		"runtime"
	)

	func main() {
		log.SetFlags(log.LstdFlags | log.Lshortfile)
		log.Printf("os:%s arch:%s", runtime.GOOS, runtime.GOARCH)
	}
编译
	$CGO_ENABLED=0 GOARCH=arm GOOS=linux go build -o tos tos.go
上传
	方式一: scp -P 2222 ./tos root@192.168.1.152:/data/data/berserker.android.apps.sshdroid/home/tmp
	方式二: adb push    ./tos /data/data/berserker.android.apps.sshdroid/home/tmp
运行
	方式一: ssh root@192.168.1.152
	方式二: adb shell
	cd /data/data/berserker.android.apps.sshdroid/home/tmp
	chmod +x ./tos
	./tos


scp -P 2222 ./ipfs root@192.168.1.152:/data/data/berserker.android.apps.sshdroid/home/tmp
scp -P 2222 ./swarm.key root@192.168.1.152:/data/data/berserker.android.apps.sshdroid/home/.ipfs

./ipfs bootstrap add /ip4/192.168.1.106/tcp/4001/ipfs/QmbHSSGasagTkVdxymVpU5W2DYSMyYdsHMwGgZ5dmp15gn

npm install --unsafe-perm=true --allow-root



nodejs.api
https://github.com/ipfs/go-ipfs-api



sudo apt-get install build-essential libssl-dev libcurl4-gnutls-dev libexpat1-dev gettext unzip



multi-format: multi是由多部分组成的,类似于通讯协议里的TLV结构 format有针对通讯的/存储的
Self Describing format: 指的是TLV中说明了Type length
Self-Certifying File System: 指的是TLV中V的自我签名/摘要验证

MerkeleTree
	叶子是数据块(例如文件交易)的hash值,非叶子节点是对应子节点字符串的hash值
MerkeleDAG   directed acyclic graph 有向无环图
	  将文件分成若干部分,并计算各部分的hash值,利用这些hash值构建对应文件的DAG,DAG的根节点就是文件的hash值
	  节点包括2部分,Data和link; Data为二进制,Link包含Name hash size这3部分
	  特点
	  	内容寻址  使用多重hash来唯一标识一个数据块的内容
		防篡改    使用hash来确定数据是否被篡改
		去重      由于内容相同的数据块 hash值是相同的,很容易去掉重复的数据,节省存储空间
IPLD  interPlanetary Linked Data
	  数据格式转换中间件 将现有的异构数据(比特币以太坊的块数据等)统一成一种统一的标准格式进行传输
CID   内容识别符 实际就是返回的hash值 如/ipfs/xxxxxxx中的xxxx


协议栈
	加密/描述数据 multiformats  用于加密和描述nodeID和contentID的生成
		身份				Self Describing format
	传递数据	     libp2p	       用于适配各种各样的传输层协议和连接众多复杂的设备
		网络层Network   establishing connections between peers                       config文件里的bootstrap节点定义了ip/协议          
		路由层Routing   locating peers and objects              DHT结构                  value长度小的值直接存储到dht上;更大的值,dht只存储值索引,索引就是一个节点的NodeID
		交换层Exchange  block transport and replication         BitSwap协议/BitTorrent
	结构数据  IPLD 
		对象层Object                                            MerkleDAG/IPLD        个人理解单节点MerkleDAG, 节点之间IPLD CID
		文件层File                                              Git                   可以通过ipfs object links $root-hash
		命名层Naming    a Self-certifying PKI namespace (IPNS)  IPNS/SFS自验证文件系统 Self-Certifying File System
	应用数据
		ipfs
	价值数据
		FileCoin                                                激励 交易






ipfs dag
	put        //echo  "ccccc" | ipfs dag put
	get        //ipfs dag get $hash
	resolve
ipfs block 操作raw ipfs blocks的plumbing command 底层命令
	put         //echo "aaaa" | ipfs block put
	get  $hash
	rm   $hash
	stat $hash  //返回hash和size
ifps object  操作dag的plumbing command 底层命令
	put <data> 
	get $hash
	data $hash
	stat $hash
	links $hash   #可以从返回的links字段是一个数组,这个数组里的每个元素的name字段依据"/"分割形成一棵树,  这就是所谓的DAG

	diff  <obj-a obj-b>
	new   [template]
	patch
		patch add-link
		patch append-data  $hash $data
		patch rm-link
ipfs files
	write    //echo "hello world" | ipfs files write --create -p /myfs/a
	flush    //ipfs files flush  /myfs/a
	read     //ipfs files read /myfs/a
	ls       //ipfs files ls  /myfs
	rm       //ipfs files rm   /myfs/a
	stat     //ipfs files stat /myfs/a

	cp
	mkdir   //ipfs files mkdir -p /test/does/not/exist/yet
	mv


bootstrap 启动节点
	add
	rm
	rm all
	list
dht  分布式hash表
	findpeer   `ipfs id` 
	findprovs  $hash   //返回哪些peer可以提供查询这个hash 即hash内容的分部部署情况
	put
	query
diag 诊断
	cmds
	cmds clear
	cmds set-time
	sys
ipfs bitswap  交换协议
	ledger
	reprovide
	stat
	wantlist

cid内容识别符
	base32
	bases
	codes
	format
	hashes
config
	edit
	profile
	profile apply
	replace
	show
key
	gen
	list
	rename
	rm
log
	level
	ls
	tail

ipfs filestore
	dups
	ls
	verify
name
	publish
	pubsub
	pubsub cancel
	pubsub state
	resolve

p2p
	close
	forward
	listen
	stream
	stream close
	stream ls












FileCoin 
	去中心化存储网络协议 DSN  Decentralized Storage Network
	报价 ask
	出价 bid
	订单簿 Order  订单的合集



	链上 On Chain
	链下 Off Chain

	复制证明ProofOfReplication PoRep 权益证明ProofOfStorage
		用户发送数据到矿工,矿工接收数据并给出数据已存储的证明   
	时空证明ProofOfSpacetime PoSt    算力证明ProofOfWork
		矿工存储完之后,该订单写入区块链永久保存,区块链清算支付结果. 此后矿工要不断的向网络证明(时空证明)自己一直存储有该数据,直到该数据存储合约到期
		一连串的复制证明
		反映了一段时间内存储矿工的算力的大小

https://blog.csdn.net/xin1889/article/details/80025564

user:password@host:port


nmtui  pe
ip/mask_len     10.0.0.10/8 已知IP是32位,8位掩码即255.0.0.0
Gateway
DNS
Routing

IP 
	cat /etc/sysconfig/network-scripts/ifcfg-eth0
		NAME=eth0                                               ##指定网络链接的名字为eth0，个人习惯，开心就好
		DEVICE=eth0                                             ##指定文件管理的网卡名称
		ONBOOT=yes                                              ##是否开机启动

		####DHCP网络配置####
		BOOTPROTO=dhcp                                          ##dhcp动态获取，none和static都表示静态网络  dynamic host configuration protocol
		
		####静态网络地址配置####
		BOOTPROTO=static                                        ##dhcp动态获取，none和static都表示静态网络
		IPADDR=10.0.0.10                                        ##设定ip为10.0.0.10
		NETMASK=255.0.0.0|PREFIX=8                              ##子网掩码为255.0.0.0
		
		GATEWAY=10.0.0.1                                        ##网关地址,如果需要访问外网需要设置
		DNS=***.***.***.***                                     ##DNS地址，如需域名解析需要设置
		PEERDNS=yes|no                                          ##是否修改/etc/resolv.conf,no表示不修改
		####IPADDR、NETMASK、PREFIX、GATEWAY、DNS后面加数字,可以同时设置多组IP地址
		####当然还有更多的参数可以配置,如果需要可以查看帮助文档/usr/share/doc/initscripts-*/sysconfig.txt


	命令
		ifconfig 
			查看
				查看active 和 loop
				-a      所有接口,包括非活动的
				eth0    特定接口

			动态获取IP
				ifconfig eth0 --dynamic    

			临时修改,重启机器重新读取配置文件
				ifconfig eth0 192.168.1.222   netmask 255.255.255.0
				ifconfig eth0:1 192.168.1.222 netmask 255.0.0.0
				ifconfig eth0 hw ether MAC地址                            #修改mac地址  先ifdown   eth0; 再修改 最后ifup     eth0;

			启动/停止
				ifconfig eth0 up
				ifconfig eth0 down
				ifdown   eth0;
				ifup     eth0;

		dhclient 可以从dhcp服务器申请新的网络配置(ip-gateway-dns)到当前主机

		nmcli device show eth0
		nmcli device status eth0

Gateway 接收发送方请求

路由  将发送方的IP地址进行转换
	域名解析DNS
		本地
			cat /etc/hosts   类似于windows的host文件
				127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4 ipfs1
				::1         localhost localhost.localdomain localhost6 localhost6.localdomain6 ipfs1

		网络  
			格式 ServerName	IP   
			最多可以设置3行，前面的生效
			万能DNS 114.114.114.114
			cat /etc/resolv.conf
				# Generated by NetworkManager
				nameserver 202.96.128.86
				nameserver 202.96.134.33


	优先级
		先查询本地host 本地dns 根域dns服务器 .com服务器 baidu.com服务器

	命令
		host  www.google.com
		nslookup    直接模式一般用于查询域名对应的IP   交互模式用于对DNS服务器进行测试
			nslookup www.sohu.com.cn
				Server:		202.96.128.86                          #本地配置的dns的IP地址
				Address:	202.96.128.86#53

				Non-authoritative answer:
				www.sohu.com.cn	canonical name = gd.a.sohu.com.
				gd.a.sohu.com	canonical name = f7gz.a.sohu.com.
				Name:	f7gz.a.sohu.com
				Address: 14.18.240.77
		dig

		route    
			echo 1 > /proc/sys/netipv4/ip_forward  #1打开路由功能 0为关闭路由功能
			查看主机路由信息route -n #类似于netstat -tlpn中的n将主机名转化为IP default转化为0.0.0.0
				Kernel IP routing table
				Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
				default         gateway         0.0.0.0         UG    100    0        0 eth0
				192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0
			修改
				route del default gw   #route del –net 0.0.0.0 netmask 0.0.0.0 gw 192.168.0.1
				route add default gw   #route add –net 0.0.0.0 netmask 0.0.0.0 gw 192.168.0.1
		traceroute 一般用于查看到目录所经过的路径
			traceroute www.baidu.com

主机名
	cat /etc/sysconfig/network
		NETWORKING=yes      #网络是否可用。
	　　HOSTNAME=xxxx       #xxxx为新设置的主机名。

	命令
		hostname
			查看
			修改 
				hostname yy



/etc/rc.d/init.d/network start
service network restart
/etc/rc.d/rc.local


